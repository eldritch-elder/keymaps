#+title: keymaps
#+author: Freja
#+startup: content

* The keymap
** The layout
I primarily type in German, English and Swedish so the keyboard should be cabable or outputing the used characters like ~ü~ or ~å~.
For that I am using [[https://eurkey.steffen.bruentjen.eu/][EurKey]] - but US Intl should be fine too - on my system.  These are QWERTY layouts but they are able to output letters used in different languages using Alt Gr aka Right Alt.

*** Base layer
On the keyboard however I will use a modified version of [[https://sites.google.com/alanreiser.com/handsdown/home?authuser=0#h.rt23wndkh65l][hands down gold]], until something better comes up.
#+name: base_layout
| &nop | &kp z | &kp f | &kp m    | &kp p   | &kp v    |          |          |           |           | &kp semi  | &kp dot  | &kp fslh | &kp sqt | &kp equal | &nop |
| &nop | &kp r | &kp s | &kp n    | &kp d   | &kp w    |          |          |           |           | &kp comma | &kp a    | &kp e    | &kp i   | &kp o     | &nop |
| &nop | &kp x | &kp g | &kp l    | &kp c   | &kp b    | &mo _adj | &kp gesc | &tg _game | &nop      | &kp minus | &kp h    | &kp u    | &kp j   | &kp k     | &nop |
|      |       |       | &kp lgui | &kp tab | &mo _low | &kp t    | &kp ret  | &kp bspc  | &kp space | &mo _high | &kp ralt | &kp mute |         |           |      |
*** g*ming layout
Too lazy to config shit in every game I use a keyboard with.
#+name: game_layout
| &nop | &kp a | &kp w | &kp e    | &kp r   | &kp t    |                |          |           |      | &nop   | &nop   | &kp n3   | &kp n4 | &nop   | &nop |
| &nop | &kp q | &kp s | &kp d    | &kp f   | &kp g    |                |          |           |      | &kp n7 | &kp n1 | &kp n2   | &kp n5 | &kp n6 | &nop |
| &nop | &kp z | &kp x | &kp c    | &kp v   | &kp b    | &kp lsft       | &kp gesc | &tg _game | &nop | &nop   | &nop   | &nop     | &nop   | &nop   | &nop |
|      |       |       | &kp lgui | &kp tab | &kp lalt | &lt _low space | &kp ret  | &nop      | &nop | &nop   | &nop   | &kp mute |        |        |      |
*** lower layer
#+name: low_layout
| &nop | &kp n1 | &kp n2   | &kp n3   | &kp n4   | &kp n5 |       |       |       |       | &kps n1 | &kps n2   | &kps n3   | &kps n4   | &kps n5 | &nop |
| &nop | &kp n6 | &kp n7   | &kp n8   | &kp n9   | &kp n0 |       |       |       |       | &kps n6 | &kps n7   | &kps n8   | &kps n9   | &kps n0 | &nop |
| &nop | &trns  | &kp bslh | &kp lbrc | &kp rbrc | &trns  | &trns | &trns | &trns | &trns | &trns   | &kps lbrc | &kps rbrc | &kps bslh | &trns   | &nop |
|      |        |          | &trns    | &trns    | &trns  | &trns | &trns | &trns | &trns | &trns   | &trns     | &trns     |           |         |      |
*** raise layer
#+name: high_layout
| &nop | &trns    | &kp volu | &trns    | &trns     | &trns    |       |       |       |       | &trns    | &trns    | &trns  | &trns     | &trns | &nop |
| &nop | &trns    | &kp vold | &kp prev | &kp pause | &kp next |       |       |       |       | &kp left | &kp down | &kp up | &kp right | &trns | &nop |
| &nop | &kp undo | &kp cut  | &kp copy | &kp paste | &trns    | &trns | &trns | &trns | &trns | &trns    | &trns    | &trns  | &trns     | &trns | &nop |
|      |          |          | &trns    | &trns     | &trns    | &trns | &trns | &trns | &trns | &trns    | &trns    | &trns  |           |       |      |
*** adjusting shit
This layer contains stuff for adjusting, be it ~EE_HANDS~ or rgb stuff.
#+name: adj_layout
| &nop | &kp eelh  | &kp eerh  | &nop | &nop | &nop |       |      |      |      | &nop | &kp rgbhu | &kp rgbsu | &kp rgbvu | &kp rgbmu | &nop |
| &nop | &nop      | &nop      | &nop | &nop | &nop |       |      |      |      | &nop | &kp rgbhd | &kp rgbsd | &kp rgbvd | &kp rgbmd | &nop |
| &nop | &kp reset | &kp eeprt | &nop | &nop | &nop | &trns | &nop | &nop | &nop | &nop | &nop      | &nop      | &nop      | &nop      | &nop |
|      |           |           | &nop | &nop | &nop | &nop  | &nop | &nop | &nop | &nop | &nop      | &nop      |           |           |      |
** combos
Here, combos are a nice feature allowing to add keys at places where they don't impear your typing yet are comfortable to use.
It expects a table with each row taking one combo, the first cell is the result you want to have and all the following cells contain the keys you want to press to, to the key in the first cell.
Leave an empty table to disable this feature.  Leaving the first cell empty will do the trick too.
#+name: combo-table
| &kp q     | &kp z    | &kp f   |
| &kp y     | &kp m    | &kp p   |
| &kp tab   | &kp c    | &kp b   |
| &kp gesc  | &kp p    | &kp v   |
| &osm lsft | &kp f    | &kp m   |
| &osm lctl | &kp g    | &kp l   |
| &osm lgui | &kp fslh | &kp sqt |
| &osm lalt | &kp u    | &kp j   |
** encoder
Rotary encoders add a lot of features and functionality, they are extremly useful.
For me, I like to have volume control on one side and window control on the other.

Simple structure is the function ~encoder_update_user(index, clockwise)~, this runs a simple /this encoder does this when turned clockwise, this then otherwise/.
#+name: encoder
#+begin_src C :main no :tangle no :results none
bool is_alt_tab = false;
uint16_t alt_tab_timer = 0;

bool encoder_update_user(uint8_t index, bool clockwise) {
    if (index == 1) {
        if (clockwise) {
            tap_code(KC_VOLU);
        } else {
            tap_code(KC_VOLD);
        }
    } else if (index == 0) {
        if (clockwise) {
            if (!is_alt_tab) {
                is_alt_tab = true;
                register_code(KC_LALT);
            }
            alt_tab_timer = timer_read();
            tap_code16(KC_TAB);
        } else {
            if (!is_alt_tab) {
                is_alt_tab = true;
                register_code(KC_LALT);
            }
            alt_tab_timer = timer_read();
            tap_code16(S(KC_TAB));
        }
    }

    return false;
}

void matrix_scan_user(void) {
    if (is_alt_tab) {
        if (timer_elapsed(alt_tab_timer) > 800) {
            unregister_code(KC_LALT);
            is_alt_tab = false;
        }
    }
}
#+end_src
** one shot one kill
I use callums implementation for oneshot mods.  For more information check callums userspace and the joinked stuff down in [[*fixing osm stuff][the building section]].
I'm gonna take over the ~OSM()~ keycodes since this is basically osm except better.
*** canceling oneshotkeys
Since they don't use a timer and queue up indefinetly you need some way to cancel the keys when you missclicked or something.
#+name: cancel-keys
| &mo _high |
*** ignoring keys
Sometimes you don't want to activate the mods on some keys, e.g. to stack mods or use them across layers.
#+name: ignore-keys
| &osm lsft  |
| &osm rsft  |
| &osm lctl  |
| &osm rctl  |
| &osm lalt  |
| &osm ralt  |
| &osm lgui  |
| &osm rgui  |
| &mo _low   |
| &mo _high  |
* Abandon all hope, ye who enter here
This section is the build section. from this point on it's code and code only, be it elisp or c.
I would not recommend altering anything up there, escpecially the generator code, unless you know what you are doing.

I try to write it fairly pessimistic, but if anything faulty goes through, qmk will complain about it.
** generators and parser
This section contains stuff used for parsing the key definitions.
*** keycodes
#+name: keycode-parsing
#+begin_src elisp :results none
(defun get-keycode (name)
  "Returns the keycode if it exists."
  (let ((code (nth 1 (assoc name keycode))))
    (if (not code)
        (error "The key %s does't exist - yet." name)
        code)))

(defun get-mod (name)
  "Returns the mod if it exists."
  (let ((code (nth 1 (assoc name modcode))))
    (if (not code)
        (error "The mod %s does't exist." name)
        code)))

(defun parse-key (word)
  "Parses the expression and returns the keycode.  It takes a string as input and ignores empty expressions"
  (unless (eq word "")
    (pcase word
      ((or "&nop" "xxx")                                                                          "KC_NO, ")
      ((or "&trns" "___" "---")                                                                   "KC_TRNS, ")
      ;; FIXME the `rx` shit does not work when tangling with a script/in batch mode
      ((rx bos "&kp" (+ space) (let head (+ word)) (* space) eos)                                 (concat (get-keycode head) ", "))
      ((rx bos "&kps" (+ space) (let head (+ word)) (* space) eos)                                (format "S(%s), " (get-keycode head)))
      ((rx bos "&kpc" (+ space) (let head (+ word)) (* space) eos)                                (format "C(%s), " (get-keycode head)))
      ((rx bos "&kpa" (+ space) (let head (+ word)) (* space) eos)                                (format "A(%s), " (get-keycode head)))
      ((rx bos "&kpg" (+ space) (let head (+ word)) (* space) eos)                                (format "G(%s), " (get-keycode head)))
      ((rx bos "&tg" (+ space) (let head (+ word)) (* space) eos)                                 (format "TG(%s), " head))
      ((rx bos "&lt" (+ space) (let arg (+ word)) (+ space) (let head (+ word)) (* space) eos)    (format "LT(%s, %s), " arg (get-keycode head)))
      ((rx bos "&mo" (+ space) (let head (+ word)) (* space) eos)                                 (format "MO(%s), " head))
      ((rx bos "&mt" (+ space) (let arg (+ word)) (+ space) (let head (+ word)) (* space) eos)    (format "MT(%s, %s), " (get-mod arg) (get-keycode head)))
      ((rx bos "&osm" (+ space) (let head (+ word)) (* space) eos)                                (format "OSM(%s), " (get-mod head)))
      (-                                                                                          (error "unknown expr `%s`" word)))))
#+end_src
**** tables n shit
A not so complete list of keycodes
#+name: keycode_table
| a     | KC_A      |
| b     | KC_B      |
| c     | KC_C      |
| d     | KC_D      |
| e     | KC_E      |
| f     | KC_F      |
| g     | KC_G      |
| h     | KC_H      |
| i     | KC_I      |
| j     | KC_J      |
| k     | KC_K      |
| l     | KC_L      |
| m     | KC_M      |
| n     | KC_N      |
| o     | KC_O      |
| p     | KC_P      |
| q     | KC_Q      |
| r     | KC_R      |
| s     | KC_S      |
| t     | KC_T      |
| u     | KC_U      |
| v     | KC_V      |
| w     | KC_W      |
| x     | KC_X      |
| y     | KC_Y      |
| z     | KC_Z      |
| n1    | KC_1      |
| n2    | KC_2      |
| n3    | KC_3      |
| n4    | KC_4      |
| n5    | KC_5      |
| n6    | KC_6      |
| n7    | KC_7      |
| n8    | KC_8      |
| n9    | KC_9      |
| n0    | KC_0      |
| ret   | KC_ENTER  |
| esc   | KC_ESC    |
| gesc  | KC_GESC   |
| bspc  | KC_BSPACE |
| del   | KC_DEL    |
| tab   | KC_TAB    |
| space | KC_SPACE  |
| minus | KC_MINUS  |
| equal | KC_EQUAL  |
| lbrc  | KC_LBRC   |
| rbrc  | KC_RBRC   |
| fslh  | KC_SLASH  |
| bslh  | KC_BSLASH |
| semi  | KC_SCOLON |
| dot   | KC_DOT    |
| comma | KC_COMMA  |
| sqt   | KC_QUOTE  |
| grave | KC_GRAVE  |
| lsft  | KC_LSHIFT |
| rsft  | KC_RSHIFT |
| lctl  | KC_LCTRL  |
| rctl  | KC_RCTRL  |
| lalt  | KC_LALT   |
| ralt  | KC_RALT   |
| lgui  | KC_LGUI   |
| rgui  | KC_RGUI   |
| mute  | KC_MUTE   |
| left  | KC_LEFT   |
| down  | KC_DOWN   |
| up    | KC_UP     |
| right | KC_RIGHT  |
| volu  | KC_VOLU   |
| vold  | KC_VOLD   |
| pause | KC_MPLY   |
| next  | KC_MNXT   |
| prev  | KC_MPRV   |
| undo  | KC_UNDO   |
| cut   | KC_CUT    |
| copy  | KC_COPY   |
| paste | KC_PASTE  |
| eelh  | EH_LEFT   |
| eerh  | EH_RGHT   |
| rgbhu | RGB_HUI   |
| rgbhd | RGB_HUD   |
| rgbsu | RGB_SAI   |
| rgbsd | RGB_SAD   |
| rgbvu | RGB_VAI   |
| rgbvd | RGB_VAD   |
| rgbmu | RGB_MOD   |
| rgbmd | RGB_RMOD  |
| reset | RESET     |
| eeprt | EEP_RST   |

A semi complete list of modifier codes
#+name: mod_table
| lsft | MOD_LSFT |
| rsft | MOD_RSFT |
| lctl | MOD_LCTL |
| rctl | MOD_RCTL |
| lalt | MOD_LALT |
| ralt | MOD_RALT |
| lgui | MOD_LGUI |
| rgui | MOD_RGUI |
*** layers
For processing the table and generating the layers
#+name: generate-layer
#+begin_src elisp :var input=base_layout keycode=keycode_table modcode=mod_table :noweb yes :results value drawer
<<keycode-parsing>>

(setq input (flatten-tree input) ; flat is justice
      result "")

(while input
  (let ((word (pop input)))
    (setq result (concat result (parse-key word)))))

(substring result 0 -2)  ; cutting of the last `,` since c macros can't handle trailing commas for shit
;(s-chop-suffix ", " result) <- doesn't work outside emacs
#+end_src
*** combos
Parsing and generating the code for the combos
#+name: combo-enable
#+begin_src elisp :main no :var in=combo-table :result value drawer
(if (equal (caar in) "")
    "no" "yes")
#+end_src

#+name: get-combocount
#+begin_src elisp :main no :var in=combo-table :result value drawer
(length in)
#+end_src

#+name: generate-combosequence
#+begin_src elisp :main no :noweb yes :var in=combo-table keycode=keycode_table modcode=mod_table :result value drawer
<<keycode-parsing>>

(setq result ""
      id 0)  ; too lazy to create names, I just use a running number

(unless (eq (caar in) "")
  (while in
    (setq row (cdr (pop in)))
    (setq result (concat result (format "const uint16_t PROGMEM unique_combo%d[] = { " id)))
    (while row
      (setq result (concat result (parse-key (pop row)))))
    (setq result (concat result "COMBO_END, };\n"))
    (setq id (1+ id)))

    (print result))
#+end_src

#+name: generate-combocombination
#+begin_src elisp :main no :noweb yes :var in=combo-table keycode=keycode_table modcode=mod_table :result value drawer
<<keycode-parsing>>

(setq result "combo_t key_combos[COMBO_COUNT] = { "
      id 0)

(unless (eq (caar in) "")
  (while in
    (setq key (car (pop in))
          result (concat result (format "COMBO(unique_combo%d, %s), " id (s-chop-suffix ", " (parse-key key))))
          id (1+ id)))
  (concat result "};"))
#+end_src
*** osm
#+name: cancel_osm
#+begin_src elisp :main no :noweb yes :var in=cancel-keys keycode=keycode_table modcode=mod_table :results value drawer
<<keycode_parsing>>

(setq result "bool is_oneshot_cancel_key(uint16_t keycode) {\n  switch (keycode) {\n")

(while in
  (unless (eq (parse-key (caar in)) "")
    (setq result (concat result "    case " (s-chop-suffix ", " (parse-key (car (pop in)))) ":\n"))))

(concat result "      return true;\n    default:\n      return false;\n  }\n}")
#+end_src

#+name: ignore_osm
#+begin_src elisp :main no :noweb yes :var in=ignore-keys keycode=keycode_table modcode=mod_table :results value drawer
<<keycode_parsing>>

(setq result "bool is_oneshot_ignored_key(uint16_t keycode) {\n  switch (keycode) {\n")

(while in
  (unless (eq (parse-key (caar in)) "")
    (setq result (concat result "    case " (s-chop-suffix ", " (parse-key (car (pop in)))) ":\n"))))

(concat result "      return true;\n    default:\n      return false;\n  }\n}")
#+end_src

** stuff
Here we take everything from the section before and format these accordingly before taking everything together.
*** header
#+name: header
#+begin_src C :main no :tangle no :results none
/* vim:ro
 * -*- buffer-read-only: t -*-
 *
 * This is autogenerated using babel DO NOT EDIT.
 * Please refer to main.org in [[https://git.sr.ht/~jat/keymap]]
 *
 *
 * Copyright 2021 Freja
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#+end_src

*** matrix stuff
#+name: keymap
#+begin_src C :main no :tangle no :noweb yes :results none
enum layers { _base = 0, _game, _low, _high, _adj, };

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
         [_base] = LAYOUT(<<generate-layer(input=base_layout)>>),
         [_game] = LAYOUT(<<generate-layer(input=game_layout)>>),
         [_low] = LAYOUT(<<generate-layer(input=low_layout)>>),
         [_high] = LAYOUT(<<generate-layer(input=high_layout)>>),
         [_adj] = LAYOUT(<<generate-layer(input=adj_layout)>>),
};
#+end_src

*** combo stuff
#+name: combo
#+begin_src C :main no :noweb yes :result none
<<generate-combosequence()>>
<<generate-combocombination()>>
#+end_src
*** fixing osm stuff
#+name: oneshot
#+begin_src C :main no :noweb yes :results none
<<cancel_osm()>>

<<ignore_osm()>>

<<oneshot_implementation>>

oneshot_state sft_state = os_up_unqueued;
oneshot_state ctl_state = os_up_unqueued;
oneshot_state alt_state = os_up_unqueued;
oneshot_state gui_state = os_up_unqueued;
#+end_src

#+name: update_oneshot_states
#+begin_src C :main no :results none
update_oneshot(&sft_state, KC_LSHIFT, OSM(MOD_LSFT), keycode, record);
update_oneshot(&ctl_state, KC_LCTRL, OSM(MOD_LCTL), keycode, record);
update_oneshot(&alt_state, KC_LALT, OSM(MOD_LALT), keycode, record);
update_oneshot(&gui_state, KC_LGUI, OSM(MOD_LGUI), keycode, record);
#+end_src

#+name: override_oneshot
#+begin_src C :main no :results none
case OSM(MOD_LSFT):
case OSM(MOD_RSFT):
case OSM(MOD_LCTL):
case OSM(MOD_RCTL):
case OSM(MOD_LALT):
case OSM(MOD_RALT):
case OSM(MOD_LGUI):
case OSM(MOD_RGUI):
    return false;
#+end_src
**** the implementation
I just joinked callums oneshot implementation since I don't want to deal with foreign userspace stuff and depend on those.  Look at callums userspace for more information.
#+name: oneshot_implementation
#+begin_src C :main no :results none
// the different states a oneshot key can be in
typedef enum {
    os_up_unqueued,
    os_up_queued,
    os_down_unused,
    os_down_used,
} oneshot_state;

void update_oneshot(oneshot_state *state, uint16_t mod, uint16_t trigger, uint16_t keycode, keyrecord_t *record) {
    if (keycode == trigger) {
        if (record->event.pressed) {
            // Trigger keydown
            if (*state == os_up_unqueued) {
                register_code(mod);
            }
            ,*state = os_down_unused;
        } else {
            // Trigger keyup
            switch (*state) {
                case os_down_unused:
                    // If we didn't use the mod while trigger was held, queue it.
                    ,*state = os_up_queued;
                    break;
                case os_down_used:
                    // If we did use the mod while trigger was held, unregister it.
                    ,*state = os_up_unqueued;
                    unregister_code(mod);
                    break;
                default:
                    break;
            }
        }
    } else {
        if (record->event.pressed) {
            if (is_oneshot_cancel_key(keycode) && *state != os_up_unqueued) {
                // Cancel oneshot on designated cancel keydown.
                ,*state = os_up_unqueued;
                unregister_code(mod);
            }
        } else {
            if (!is_oneshot_ignored_key(keycode)) {
                // On non-ignored keyup, consider the oneshot used.
                switch (*state) {
                    case os_down_unused:
                        ,*state = os_down_used;
                        break;
                    case os_up_queued:
                        ,*state = os_up_unqueued;
                        unregister_code(mod);
                        break;
                    default:
                        break;
                }
            }
        }
    }
}
#+end_src
** putting it all together
*** keymap.c
#+begin_src C :noweb yes :tangle keymap.c :results none :no-expand
<<header>>

#include QMK_KEYBOARD_H

<<keymap>>

#ifdef ENCODER_ENABLE
<<encoder>>
#endif

<<combo>>

<<oneshot>>

bool process_record_user(uint16_t keycode, keyrecord_t *record) {
    <<update_oneshot_states>>

    switch (keycode) {
        <<override_oneshot>>
        default: return true;
    }
}
#+end_src

*** config.h
#+begin_src C :noweb yes :tangle config.h :results none :no-expand
<<header>>

#pragma once

#define EE_HANDS

#define LAYER_STATE_8BIT

#define TAPPING_TERM 300
#define IGNORE_MOD_TAP_INTERRUPT

#ifdef OLED_DRIVER_ENABLE
#define OLED_DISPLAY_128X64
#endif

#ifdef NKRO_ENABLE
#define FORCE_NKRO
#endif

#ifdef RGBLIGHT_ENABLE
#define RGBLIGHT_LED_MAP {0,1,2,9,8,7,4,3,5,6,19,18,17,10,11,12,15,16,14,13}
#define RGBLIGHT_SLEEP
#define RGBLIGHT_EFFECT_BREATHING
#define RGBLIGHT_EFFECT_KNIGHT

#define RGBLIGHT_HUE_STEP 8
#define RGBLIGHT_SAT_STEP 8
#define RGBLIGHT_VAL_STEP 8
#define RGBLIGHT_LIMIT_VAL 150
#endif

#ifdef ENCODER_ENABLE
#define ENCODER_RESOLUTION 2
#define ENCODER_DIRECTION_FLIP
#endif

#ifdef COMBO_ENABLE
#define COMBO_COUNT <<get-combocount()>>
#endif

// define USB_POLLING_INTERVAL_MS 5
#+end_src

*** rules.mk
#+begin_src C :tangle rules.mk :noweb yes :results none :no-expand
OLED_DRIVER_ENABLE = no
WPM_ENABLE = no
RGBLIGHT_ENABLE = yes
COMBO_ENABLE = <<combo-enable()>>
ENCODER_ENABLE = yes

BOOTLOADER=qmk-hid
BOOTLOADER_SIZE=512
#+end_src
