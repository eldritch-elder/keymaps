#+title: keymap
#+author: Freja 'jat
#+startup: content

* The keymap
** The layout
#+name: keycount
| 40 |

#+name: layers
| _base  |
| _lower |
| _raise |
| _adj   |

*** Base layer
#+name: base_layer
| xxx   | xxx   | &kp F | &kp M      | &kp P | &kp V      |   | &kp SEMI  | &kp DOT   | &kp FSLH   | &kp SQT | xxx   | &kp RALT  |
| &kp Z | &kp R | &kp S | &kp N      | &kp D | &kp W      |   | &kp COMMA | &kp A     | &kp E      | &kp I   | &kp O | &kp EQUAL |
|       | &kp X | &kp G | &kp L      | &kp C | &kp B      |   | &kp MINUS | &kp H     | &kp U      | &kp Y   | &kp K |           |
|       |       |       | &mo _lower | &kp T | &kp RETURN |   | &kp TAB   | &kp SPACE | &mo _raise |         |       |           |

*** qwerty
if i ever need qwerty for no reason whatsoever
| xxx | &kp q | &kp w | &kp e      | &kp r | &kp t      |   | &kp y     | &kp u     | &kp i      | &kp o | &kp p | xxx |
| xxx | &kp r | &kp s | &kp n      | &kp d | &kp w      |   | &kp comma | &kp a     | &kp e      | &kp i | &kp o | xxx |
|     | &kp x | &kp g | &kp l      | &kp c | &kp b      |   | &kp minus | &kp h     | &kp u      | &kp y | &kp k |     |
|     |       |       | &mo _lower | &kp t | &kp RETURN |   | &kp lsft  | &kp space | &mo _raise |       |       |     |

*** artsey.io
| xxx | &kp s | &kp t | &kp r | &kp a | xxx |   | xxx | xxx | xxx      | xxx | xxx | xxx |
| xxx | &kp o | &kp i | &kp y | &kp e | xxx |   | xxx | xxx | xxx      | xxx | xxx | xxx |
|     | xxx   | xxx   | xxx   | xxx   | xxx |   | xxx | xxx | xxx      | xxx | xxx |     |
|     |       |       | xxx   | xxx   | xxx |   | xxx | xxx | &mo _adj |     |     |     |

| &kp b     | 13 | 16 |    |    |
| &kp c     | 15 | 16 |    |    |
| &kp d     |  2 |  3 |  4 |    |
| &kp f     |  3 |  4 |    |    |
| &kp g     |  2 |  3 |    |    |
| &kp h     | 14 | 16 |    |    |
| &kp j     |  1 |  2 |    |    |
| &kp k     | 13 | 15 |    |    |
| &kp l     | 14 | 15 | 16 |    |
| &kp m     | 13 | 14 | 15 |    |
| &kp n     | 13 | 14 |    |    |
| &kp p     | 13 | 14 | 16 |    |
| &kp q     |  1 |  2 |  4 |    |
| &kp u     | 14 | 15 |    |    |
| &kp v     |  1 |  3 |    |    |
| &kp w     |  1 |  4 |    |    |
| &kp x     |  1 |  2 |  3 |    |
| &kp z     |  1 |  2 |  3 |  4 |
| &kp sqt   | 14 | 15 |  4 |    |
| &kp dot   | 15 |  4 |    |    |
| &kp comma | 14 |  4 |    |    |
| &kp fslh  | 13 |  4 |    |    |
| &kp space | 13 | 14 | 15 | 16 |
| &kp ret   |  4 | 16 |    |    |
| &kp esc   | 13 |  3 |  4 |    |
| &osm lsft |  1 |  2 |  3 | 16 |
| &osm lctl |  1 | 16 |    |    |
| &osm lalt |  1 | 14 |    |    |
| &osm lgui |  1 | 15 |    |    |
| &kp caps  | 13 | 14 | 15 |  4 |

*** lower layer
#+name: low_layer
| --- | &kp N1 | &kp N2 | &kp N3 | &kp N4 | &kp N5 |   | &kp LS(N1) | &kp LS(N2) | &kp LS(N3) | &kp LS(N4) | &kp LS(N5) | --- |
| --- | &kp N6 | &kp N7 | &kp N8 | &kp N9 | &kp N0 |   | &kp LS(N6) | &kp LS(N7) | &kp LS(N8) | &kp LS(N9) | &kp LS(N0) | --- |
|     | ---    | ---    | ---    | ---    | ---    |   | ---        | ---        | ---        | ---        | ---        |     |
|     |        |        | ---    | ---    | ---    |   | ---        | ---        | ---        |            |            |     |

*** raise layer
#+name: high_layer
| --- | &kp PRINTSCREEN | --- | --- | --- | --- |   | &kp C_PREV | &kp C_PLAY_PAUSE | &kp C_NEXT | ---       | --- | --- |
| --- | ---             | --- | --- | --- | --- |   | &kp LEFT   | &kp DOWN         | &kp UP     | &kp RIGHT | --- | --- |
|     | ---             | --- | --- | --- | --- |   | ---        | ---              | ---        | ---       | --- |     |
|     |                 |     | --- | --- | --- |   | &mo _adj   | ---              | ---        |           |     |     |

*** adjusting shit
#+name: adj_layer
| &rgb_ug RGB_HUI | &rgb_ug RGB_SAI | &rgb_ug RGB_BRI | xxx         | xxx              | xxx |   | xxx | xxx | xxx | xxx | xxx | &rgb_ug RGB_ON  |
| &rgb_ug RGB_HUD | &rgb_ug RGB_SAD | &rgb_ug RGB_BRD | xxx         | xxx              | xxx |   | xxx | xxx | xxx | xxx | xxx | &rgb_ug RGB_OFF |
|                 | xxx             | xxx             | xxx         | xxx              | xxx |   | xxx | xxx | xxx | xxx | xxx |                 |
|                 |                 |                 | &reset      | &bootloader      | xxx |   | xxx | xxx | xxx |     |     |                 |

** macros
ye, gotta do some macros
#+name: macro-table
| rainbow | :string ":rainbow::rainbow2:" |   |

** combos
Since i'm defining combos using the positions they are all based on the base layer making them independent of the active layer.
#+name: combo-table
| &kp LBRC          |  3 | 16 |    |
| &kp LBKT          | 14 | 16 |    |
| &kp RBKT          | 19 | 21 |    |
| &kp RBRC          | 19 |  8 |    |
| &kp Q             |  1 |  2 |    |
| &kp J             |  3 |  4 |    |
| &kp RA(A)         | 25 | 27 |    |
| &kp RA(U)         | 30 | 32 |    |
| &kp RA(O)         | 30 | 33 |    |
| &sk LSFT          |  8 |  9 |    |
| &sk LCTL          | 25 | 26 |    |
| &sk LALT          | 31 | 32 |    |
| &caps_word        |  4 |  7 |    |
| &kp ESCAPE        | 13 | 16 |    |
| &kp BACKSPACE     | 19 | 20 |    |
| &kp LC(BACKSPACE) | 19 | 20 | 21 |
| &kp LS(N1)        |  2 |  3 | 16 |
| &kp LS(FSLH)      | 14 | 15 |  4 |
| &kp BSLH          | 12 | 16 |    |
| &kp GRAVE         |  9 | 10 |    |
| &kp LS(GRAVE)     | 32 | 33 |    |
| &kp LS(SQT)       |  7 | 10 |    |
| &kp LS(SEMI)      |  6 |  7 |    |
| &kp LS(N9)        |  2 | 16 |    |
| &kp LS(N0)        | 19 |  9 |    |
| &kp LS(EQUAL)     | 29 | 30 |    |
| &rainbow          |  0 | 24 |    |

Heres a table with the positions for reference:
|  0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |  8 |  9 | 10 | 11 |
| 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 |
|    | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 32 | 33 |    |
|    |    |    | 34 | 35 | 36 | 37 | 38 | 39 |    |    |    |


* Abandon all hope, ye who enter here
This section is the build section. From this point on it's code and code only.
I would not recommend altering anything down there, escpecially the generator code, unless you know what you are doing.

I try to write it fairly pessimistic, but if anything faulty goes through, zmk will complain about it.

** generators and parser
This section contains stuff used for parsing the key definitions.

*** keycodes
#+name: keycode-parsing
#+begin_src elisp :results none
(defun parse-key (word)
  "parse the keycode (and check if the syntax is correct <-- TBA)"
    (pcase word
      ((or "&none" "xxx")   "&none")
      ((or "&trans" "---")  "&trans")
      (-                    (print word))))
      ;; ((rx bos "&kp" (+ space) (let head (+ word)) (* space) eos)                                 (format "&kp %s" (get-keycode head)))
      ;; ((rx bos "&kps" (+ space) (let head (+ word)) (* space) eos)                                (format "&kp LS(%s)" (get-keycode head)))
      ;; ((rx bos "&kpc" (+ space) (let head (+ word)) (* space) eos)                                (format "&kp LC(%s)" (get-keycode head)))
      ;; ((rx bos "&kpa" (+ space) (let head (+ word)) (* space) eos)                                (format "&kp LA(%s)" (get-keycode head)))
      ;; ((rx bos "&kpag" (+ space) (let head (+ word)) (* space) eos)                               (format "&kp RA(%s)" (get-keycode head)))
      ;; ((rx bos "&kpg" (+ space) (let head (+ word)) (* space) eos)                                (format "&kp LG(%s)" (get-keycode head)))
      ;; ((rx bos "&tg" (+ space) (let head (+ word)) (* space) eos)                                 (format "&tog %s" head))
      ;; ((rx bos "&lt" (+ space) (let arg (+ word)) (+ space) (let head (+ word)) (* space) eos)    (format "&lt %s %s" arg (get-keycode head)))
      ;; ((rx bos "&mo" (+ space) (let head (+ word)) (* space) eos)                                 (format "&mo %s" head))
      ;; ((rx bos "&mt" (+ space) (let arg (+ word)) (+ space) (let head (+ word)) (* space) eos)    (format "&mt %s %s" (get-mod arg) (get-keycode head)))
      ;; ((rx bos "&osm" (+ space) (let head (+ word)) (* space) eos)                                (format "&sk %s" (get-mod head)))
      ;; ((rx bos "&rgb" (+ space) (let head (+ anychar)) (* space) eos)                                (format "&rgb_ug %s" head))
      ;; ((rx bos "&any" (+ space) (let head (* anychar) eos))                                       (format "%s" head))
#+end_src

*** layers
For processing the table and generating the layers
#+name: test-keycode
| xxx   | xxx   | &kp F | &kp M      | &kp P | &kp V      |   | &kp SEMI  | &kp DOT   | &kp FSLH   | &kp SQT | xxx   | &kp RALT  |
| &kp Z | &kp R | &kp S | &kp N      | &kp D | &kp W      |   | &kp COMMA | &kp A     | &kp E      | &kp I   | &kp O | &kp EQUAL |
|       | &kp X | &kp G | &kp L      | &kp C | &kp B      |   | &kp MINUS | &kp H     | &kp U      | &kp Y   | &kp K |           |
|       |       |       | &mo _lower | &kp T | &kp RETURN |   | &kp TAB   | &kp SPACE | &mo _raise |         |       |           |

#+name: generate-layer
#+begin_src elisp :var input=test-keycode count=keycount :noweb yes :results value drawer
<<keycode-parsing>>

(setq input (remove "" (flatten-tree input))) ; flat is justice

(let ((ln (length input))
      (x (caar count)))
  (unless (eq ln x) (error "invalid layout size, required %d, found %d" x ln)))

(concat "<" (string-join (mapcar #'parse-key input) " ") ">")
#+end_src

#+name: layer-names
#+begin_src elisp :var in=layers :results value drawer
(string-join (seq-map-indexed #'(lambda (e i) (format "#define %s %d" e i)) (flatten-tree in)) "\n")
#+end_src

*** combos
Parsing and generating the code for the combos
#+name: test-combo
| &foo | 1 |   |
| &bar | 3 | 2 |

#+name: generate-combos
#+begin_src elisp :main no :noweb yes :var in=test-combo :result value drawer
<<keycode-parsing>>

(cl-flet ((check-combo
           (row id)
           (let ((event (pop row))
                 (tail (remove "" row)))
             (if (eq event "") (error "combo %d appears to have no binding defined" id))
             (if (eq tail nil) (error "combo %d appears to have no key-positions defined" id)))))
  (seq-map-indexed #'check-combo in))

(cl-flet ((parse-combo
           (row id)
           (let* ((event (parse-key (pop row)))
                  (tail (string-join (mapcar (lambda (x) (format "%d" x)) (remove "" row)) " ")))
             (format "c%d { timeout-ms <%d>; key-positions = <%s>; bindings = <%s>; };" id 40 tail event))))
  (string-join (seq-map-indexed #'parse-combo in) "\n"))
#+end_src

*** macros
#+name: test-macro
| bar  | :press &kp F   | :tap &kp Z | :release &kp N8 |   |   |
| foo  | &kp A          | &kp B      |                 |   |   |
| fuck | :string "fuck" |            |                 |   |   |

#+name: generate-macros
#+begin_src elisp :var in=test-macro :noweb yes :results value drawer
<<keycode-parsing>>

(defun process-string (raw)
  "prases a sting to a list of keycodes for zmk to take"
  (let ((keycodes (mapcar
                   (lambda (s)
                       (setq s (string s))
                       (pcase s
                         ((rx letter)  (pcase s
                                         ((rx lower)  (format "&kp %s" (upcase s)))
                                         ((rx upper)  (error "stop shouting"))))
                         ((rx num)  (format "&kp N%s" s))
                         (":"  '"&kp COLON")
                         (-  (error "tba %s - %s" s (string s)))))
                   raw)))
    (string-join keycodes " ")))

(defun process-binding-def (raw)
  "parses a definition, returning the binding"
  (pcase raw
    ((rx bos ":press" (+ space) (let word "&" (* (or word space))) (*? space) eos)  (format "<&macro_press %s>" (parse-key word)))
    ((rx bos ":release" (+ space) (let word "&" (* (or word space))) (*? space) eos)  (format "<&macro_release %s>" (parse-key word)))
    ((rx bos (? ":tap" (+ space)) (let word "&" (* (or word space))) (*? space) eos)  (format "<&macro_tap %s>" (parse-key word)))
    ((rx bos ":string" (* space) "\"" (let word (* anychar)) "\"" (*? space) eos)  (format "<&macro_tap %s>" (process-string word)))
    (-  (error "bad definition in macro: '%s'" raw))))

(setq result "")

(while in
  (let* ((row (remove "" (pop in)))
        (label (car row))
        (bindings (string-join (mapcar #'process-binding-def (cdr row)) ", ")))
    (setq result (concat result (format "ZMK_MACRO(%s, wait-ms = <10>; tap-ms = <10>; bindings = %s;)\n" label bindings)))))

(string-trim result)
#+end_src

** stuff
Here we take everything from the section before and format these accordingly before taking everything together.
*** header
#+name: header
#+begin_src dts :main no :tangle no :results none
/* -*- buffer-read-only: t -*-
 * vim:ro
 *
 * This is autogenerated using babel DO NOT EDIT.
 * Please refer to main.org in [[https://git.sr.ht/~jat/keymap]]
 */
#+end_src

*** matrix stuff
#+name: keymap
#+begin_src dts :main no :tangle no :noweb yes :results drawer
keymap {
    compatible = "zmk,keymap";

    <<layer-names()>>

    base_layer {
        bindings = <<generate-layer(input=base_layer)>>;
        sensor-bindings = <&inc_dec_kp C_VOL_DN C_VOL_UP>;
    };

    lower_layer {
        bindings = <<generate-layer(input=low_layer)>>;
    };

    raise_layer {
        bindings = <<generate-layer(input=high_layer)>>;
    };

    adjust_layer {
        bindings = <<generate-layer(input=adj_layer)>>;
    };
}
#+end_src

*** combo stuff
#+name: combo
#+begin_src dts :main no :noweb yes :results none
combos {
    compatible = "zmk,combos";
    <<generate-combos(in=combo-table)>>
}
#+end_src

*** macrocosm
#+name: macros
#+begin_src dts :main no :noweb yes :results none
macros {
    <<generate-macros(in=macro-table)>>
}
#+end_src
*** osm stuff
#+name: osm
#+begin_src dts :results none
&sk {
    quick-release;
};
#+end_src

*** caps word
#+name: caps-word
#+begin_src dts :main no :results none
&caps_word {
    continue-list = <UNDERSCORE MINUS BSPC LSHFT RSHFT>;
};
#+end_src
** putting it all together
*** splaytoraid40.keymap
#+begin_src dts :main no :tangle config/splaytoraid40.keymap :noweb yes :no-expand :results none
<<header>>

#include <behaviors.dtsi>
#include <dt-bindings/zmk/keys.h>
#include <dt-bindings/zmk/rgb.h>

<<osm>>

<<caps-word>>

/ {
    <<macros>>;

    <<combo>>;

    <<keymap>>;
};
#+end_src

*** splaytoraid40.conf
#+begin_src conf :main no :tangle config/splaytoraid40.conf :noweb yes :noexpand :results none
CONFIG_ZMK_USB_LOGGING=n

CONFIG_ZMK_IDLE_TIMEOUT=600000

# CONFIG_ZMK_KSCAN_DEBOUNCE_PRESS_MS=7
# CONFIG_ZMK_KSCAN_DEBOUNCE_RELEASE_MS=7

CONFIG_ZMK_COMBO_MAX_COMBOS_PER_KEY=80

CONFIG_ZMK_RGB_UNDERGLOW_HUE_STEP=1
CONFIG_ZMK_RGB_UNDERGLOW_SAT_STEP=1
CONFIG_ZMK_RGB_UNDERGLOW_BRT_STEP=5
CONFIG_ZMK_RGB_UNDERGLOW_AUTO_OFF_IDLE=y
#+end_src
