#+title: keymaps
#+author: Freja
#+startup: content

* The keymap
** The layout
I primarily type in German, English and Swedish so the keyboard should be cabable or outputing the used characters like ~ü~ or ~å~.
For that I am using [[https://eurkey.steffen.bruentjen.eu/][EurKey]] - but US Intl should be fine too - on my system.  These are QWERTY layouts but they are able to output letters used in different languages using Alt Gr aka Right Alt.

*** Base layer
On the keyboard however I will use a modified version of [[https://sites.google.com/alanreiser.com/handsdown/home?authuser=0#h.rt23wndkh65l][hands down gold]], until something better comes up.
#+name: base_layout
| &nop | &kp k      | &kp f      | &kp m      | &kp p      | &kp v   |            |          |           |                 | &kp semi  | &kp dot    | &kp fslh   | &kp sqt    | &kp equal  | &nop |
| &nop | &mt lgui r | &mt lalt s | &mt lsft n | &mt lctl d | &kp w   |            |          |           |                 | &kp comma | &mt rctl a | &mt rsft e | &mt lalt o | &mt rgui i | &nop |
| &nop | &kp x      | &kp q      | &kp l      | &kp c      | &kp b   | &mo _adj   | &kp gesc | &tg _game | &nop            | &kp minus | &kp h      | &kp u      | &kp z      | &kp k      | &nop |
|      |            |            | &kp lgui   | &kp tab    | &kp del | &lt _low t | &kp ret  | &kp ralt  | &lt _high space | &kp bspc  | &nop       | &kp mute   |            |            |      |

*** g*ming layout
Too lazy to config shit in every game I use a keyboard with.
#+name: game_layout
| &nop | &kp a | &kp w | &kp e    | &kp r   | &kp t    |                |          |           |      | &nop   | &nop   | &kp n3   | &kp n4 | &nop   | &nop |
| &nop | &kp q | &kp s | &kp d    | &kp f   | &kp g    |                |          |           |      | &kp n7 | &kp n1 | &kp n2   | &kp n5 | &kp n6 | &nop |
| &nop | &kp z | &kp x | &kp c    | &kp v   | &kp b    | &kp lsft       | &kp gesc | &tg _game | &nop | &nop   | &nop   | &nop     | &nop   | &nop   | &nop |
|      |       |       | &kp lgui | &kp tab | &kp lalt | &lt _low space | &kp ret  | &nop      | &nop | &nop   | &nop   | &kp mute |        |        |      |

*** lower layer
#+name: low_layout
| &nop | &kp n1 | &kp n2   | &kp n3   | &kp n4   | &kp n5 |       |       |       |       | &kps n1 | &kps n2   | &kps n3   | &kps n4   | &kps n5 | &nop |
| &nop | &kp n6 | &kp n7   | &kp n8   | &kp n9   | &kp n0 |       |       |       |       | &kps n6 | &kps n7   | &kps n8   | &kps n9   | &kps n0 | &nop |
| &nop | &trns  | &kp bslh | &kp lbrc | &kp rbrc | &trns  | &trns | &trns | &trns | &trns | &trns   | &kps lbrc | &kps rbrc | &kps bslh | &trns   | &nop |
|      |        |          | &trns    | &trns    | &trns  | &trns | &trns | &trns | &trns | &trns   | &trns     | &trns     |           |         |      |

*** raise layer
#+name: high_layout
| &nop | &trns    | &kp volu | &trns    | &trns     | &trns    |       |       |       |       | &trns    | &trns    | &trns  | &trns     | &trns | &nop |
| &nop | &trns    | &kp vold | &kp prev | &kp pause | &kp next |       |       |       |       | &kp left | &kp down | &kp up | &kp right | &trns | &nop |
| &nop | &kp undo | &kp cut  | &kp copy | &kp paste | &trns    | &trns | &trns | &trns | &trns | &trns    | &trns    | &trns  | &trns     | &trns | &nop |
|      |          |          | &trns    | &trns     | &trns    | &trns | &trns | &trns | &trns | &trns    | &trns    | &trns  |           |       |      |

*** adjusting shit
This layer contains stuff for adjusting, be it ~EE_HANDS~ or rgb stuff.
#+name: adj_layout
| &nop | &kp eelh  | &kp eerh  | &nop | &nop | &nop |       |      |      |      | &nop | &kp rgbhu | &kp rgbsu | &kp rgbvu | &kp rgbmu | &nop |
| &nop | &nop      | &nop      | &nop | &nop | &nop |       |      |      |      | &nop | &kp rgbhd | &kp rgbsd | &kp rgbvd | &kp rgbmd | &nop |
| &nop | &kp reset | &kp eeprt | &nop | &nop | &nop | &trns | &nop | &nop | &nop | &nop | &nop      | &nop      | &nop      | &nop      | &nop |
|      |           |           | &nop | &nop | &nop | &nop  | &nop | &nop | &nop | &nop | &nop      | &nop      |           |           |      |
** combos
Here, combos are a nice feature allowing to add keys at places where they don't impear your typing yet are comfortable to use.
It expects a table with each row taking one combo, the first cell is the result you want to have and all the following cells contain the keys you want to press to, to the key in the first cell.
Leave an empty table to disable this feature.
#+name: combo-table
| &kp q | &kp z | &kp f |
| &kp q | &kp m | &kp p |
| &kp j | &kp y | &kp k |

** encoder
Rotary encoders add a lot of features and functionality, they are extremly useful.
For me, I like to have volume control on one side and window control on the other.

Simple structure is the function ~encoder_update_user(index, clockwise)~, this runs a simple /this encoder does this when turned clockwise, this then otherwise/.
#+name: encoder
#+begin_src C :main no :tangle no :results none
bool is_alt_tab = false;
uint16_t alt_tab_timer = 0;

bool encoder_update_user(uint8_t index, bool clockwise) {
    if (index == 1) {
        if (clockwise) {
            tap_code(KC_VOLU);
        } else {
            tap_code(KC_VOLD);
        }
    } else if (index == 0) {
        if (!clockwise) {
            if (!is_alt_tab) {
                is_alt_tab = true;
                register_code(KC_LALT);
            }
            alt_tab_timer = timer_read();
            tap_code16(KC_TAB);
        } else {
            if (!is_alt_tab) {
                is_alt_tab = true;
                register_code(KC_LALT);
            }
            alt_tab_timer = timer_read();
            tap_code16(S(KC_TAB));
        }
    }

    return false;
}

void matrix_scan_user(void) {
    if (is_alt_tab) {
        if (timer_elapsed(alt_tab_timer) > 800) {
            unregister_code(KC_LALT);
            is_alt_tab = false;
        }
    }
}
#+end_src



* Abandon all hope, ye who enter here
This section is the build section. from this point on it's code and code only, be it elisp or c.
I would not recommend altering anything up there, escpecially the generator code, unless you know what you are doing.

I try to write it fairly pessimistic, but if anything faulty goes through, qmk will complain about it.
** generators and parser
This section contains stuff used for parsing the key definitions.
*** keycodes
#+name: keycode-parsing
#+begin_src elisp :results none
(defun get-keycode (name)
  "Returns the keycode if it exists."
  (let ((code (nth 1 (assoc name keycode))))
    (if (not code)
        (error "The key %s does't exist - yet." name)
        code)))

(defun get-mod (name)
  "Returns the mod if it exists."
  (let ((code (nth 1 (assoc name modcode))))
    (if (not code)
        (error "The mod %s does't exist." name)
        code)))

(defun parse-key (word)
  "Parses the expression and returns the keycode.  It takes a string as input and ignores empty expressions"
  (unless (eq word "")
    (pcase word
      ((or "&nop" "xxx")                                                                          "KC_NO")
      ((or "&trns" "___" "---")                                                                   "KC_TRNS")
      ;; FIXME the `rx` shit does not work when tangling with a script/in batch mode
      ((rx bos "&kp" (+ space) (let head (+ word)) (* space) eos)                                 (get-keycode head))
      ((rx bos "&kps" (+ space) (let head (+ word)) (* space) eos)                                (format "S(%s)" (get-keycode head)))
      ((rx bos "&tg" (+ space) (let head (+ word)) (* space) eos)                                 (format "TG(%s)" head))
      ((rx bos "&lt" (+ space) (let arg (+ word)) (+ space) (let head (+ word)) (* space) eos)    (format "LT(%s, %s)" arg (get-keycode head)))
      ((rx bos "&mo" (+ space) (let head (+ word)) (* space) eos)                                 (format "MO(%s)" head))
      ((rx bos "&mt" (+ space) (let arg (+ word)) (+ space) (let head (+ word)) (* space) eos)    (format "MT(%s, %s)" (get-mod arg) (get-keycode head)))
      ((rx bos "&osm" (+ space) (let head (+ word)) (* space) eos)                                (format "OSM(%s)" (get-mod head)))
      (-                                                                                          (error "unknown expr `%s`" word)))))
#+end_src
**** tables n shit
A not so complete list of keycodes
#+name: keycode_table
| a     | KC_A      |
| b     | KC_B      |
| c     | KC_C      |
| d     | KC_D      |
| e     | KC_E      |
| f     | KC_F      |
| g     | KC_G      |
| h     | KC_H      |
| i     | KC_I      |
| j     | KC_J      |
| k     | KC_K      |
| l     | KC_L      |
| m     | KC_M      |
| n     | KC_N      |
| o     | KC_O      |
| p     | KC_P      |
| q     | KC_Q      |
| r     | KC_R      |
| s     | KC_S      |
| t     | KC_T      |
| u     | KC_U      |
| v     | KC_V      |
| w     | KC_W      |
| x     | KC_X      |
| y     | KC_Y      |
| z     | KC_Z      |
| n1    | KC_1      |
| n2    | KC_2      |
| n3    | KC_3      |
| n4    | KC_4      |
| n5    | KC_5      |
| n6    | KC_6      |
| n7    | KC_7      |
| n8    | KC_8      |
| n9    | KC_9      |
| n0    | KC_0      |
| ret   | KC_ENTER  |
| esc   | KC_ESC    |
| gesc  | KC_GESC   |
| bspc  | KC_BSPACE |
| del   | KC_DEL    |
| tab   | KC_TAB    |
| space | KC_SPACE  |
| minus | KC_MINUS  |
| equal | KC_EQUAL  |
| lbrc  | KC_LBRC   |
| rbrc  | KC_RBRC   |
| fslh  | KC_SLASH  |
| bslh  | KC_BSLASH |
| semi  | KC_SCOLON |
| dot   | KC_DOT    |
| comma | KC_COMMA  |
| sqt   | KC_QUOTE  |
| grave | KC_GRAVE  |
| lsft  | KC_LSHIFT |
| rsft  | KC_RSHIFT |
| lctl  | KC_LCTRL  |
| rctl  | KC_RCTRL  |
| lalt  | KC_LALT   |
| ralt  | KC_RALT   |
| lgui  | KC_LGUI   |
| rgui  | KC_RGUI   |
| mute  | KC_MUTE   |
| left  | KC_LEFT   |
| down  | KC_DOWN   |
| up    | KC_UP     |
| right | KC_RIGHT  |
| volu  | KC_VOLU   |
| vold  | KC_VOLD   |
| pause | KC_MPLY   |
| next  | KC_MNXT   |
| prev  | KC_MPRV   |
| undo  | KC_UNDO   |
| cut   | KC_CUT    |
| copy  | KC_COPY   |
| paste | KC_PASTE  |
| eelh  | EH_LEFT   |
| eerh  | EH_RGHT   |
| rgbhu | RGB_HUI   |
| rgbhd | RGB_HUD   |
| rgbsu | RGB_SAI   |
| rgbsd | RGB_SAD   |
| rgbvu | RGB_VAI   |
| rgbvd | RGB_VAD   |
| rgbmu | RGB_MOD   |
| rgbmd | RGB_RMOD  |
| reset | RESET     |
| eeprt | EEP_RST   |

A semi complete list of modifier codes
#+name: mod_table
| lsft | MOD_LSFT |
| rsft | MOD_RSFT |
| lctl | MOD_LCTL |
| rctl | MOD_RCTL |
| lalt | MOD_LALT |
| ralt | MOD_RALT |
| lgui | MOD_LGUI |
| rgui | MOD_RGUI |
*** layers
For processing the table and generating the layers
#+name: generate-layer
#+begin_src elisp :var input=base_layout keycode=keycode_table modcode=mod_table :noweb yes :results value
<<keycode-parsing>>

(setq input (flatten-tree input) ; flat is justice
      result "")

(while input
  (let ((word (pop input)))
    (setq result (concat result (parse-key word) (unless (eq word "") ", ")))))

(substring result 0 -2)  ; cutting of the last `,` since c macros can't handle trailing commas for shit
;(s-chop-suffix ", " result) <- doesn't work outside emacs
#+end_src

#+RESULTS: generate-layer
: KC_NO, KC_Z, KC_F, KC_M, KC_P, KC_V, KC_SCOLON, KC_DOT, KC_SLASH, KC_QUOTE, KC_EQUAL, KC_NO, KC_NO, MT(MOD_LGUI, KC_R), MT(MOD_LALT, KC_S), MT(MOD_LSFT, KC_N), MT(MOD_LCTL, KC_D), KC_W, KC_COMMA, MT(MOD_RCTL, KC_A), MT(MOD_RSFT, KC_E), MT(MOD_LALT, KC_I), MT(MOD_RGUI, KC_O), KC_NO, KC_NO, KC_X, KC_G, KC_L, KC_C, KC_B, MO(_adj), KC_GESC, TG(_game), KC_NO, KC_MINUS, KC_H, KC_U, KC_Y, KC_K, KC_NO, KC_LGUI, KC_TAB, KC_DEL, LT(_low, KC_T), KC_ENTER, KC_BSPACE, LT(_high, KC_SPACE), KC_RALT, KC_NO, KC_MUTE

*** combos
Parsing and generating the code for the combos
#+name: combo-enable
#+begin_src elisp :main no :var in=combo-table :result value
(if (equal (caar in) "")
    "no" "yes")
#+end_src

#+RESULTS: combo-enable
: yes

#+name: get-combocount
#+begin_src elisp :main no :var in=combo-table :result value
(length in)
#+end_src

#+name: generate-combosequence
#+begin_src elisp :main no :noweb yes :var in=combo-table keycode=keycode_table :result value
<<keycode-parsing>>

(setq result ""
      id 0)  ; too lazy to create names, I just use a running number

(unless (eq (caar in) "")
  (while in
    (setq row (cdr (pop in)))
    (setq result (concat result (format "const uint16_t PROGMEM unique_combo%d[] = { " id)))
    (while row
      (setq result (concat result (parse-key (pop row)) ", ")))
    (setq result (concat result "COMBO_END, };\n"))
    (setq id (1+ id)))

    (print result))
#+end_src

#+RESULTS: generate-combosequence
: const uint16_t PROGMEM unique_combo0[] = { KC_Z, KC_F, COMBO_END, };
: const uint16_t PROGMEM unique_combo1[] = { KC_M, KC_P, COMBO_END, };
: const uint16_t PROGMEM unique_combo2[] = { KC_Y, KC_K, COMBO_END, };

#+name: generate-combocombination
#+begin_src elisp :main no :noweb yes :var in=combo-table keycode=keycode_table :result value
<<keycode-parsing>>

(unless (eq (caar in) "")
  (setq result "combo_t key_combos[COMBO_COUNT] = { "
        id 0)

  (while in
    (setq key (car (pop in))
          result (concat result (format "COMBO(unique_combo%d, %s), " id (parse-key key)))
          id (1+ id)))

  (concat result "};"))
#+end_src

#+RESULTS: generate-combocombination
: combo_t key_combos[COMBO_COUNT] = { COMBO(unique_combo0, KC_Q), COMBO(unique_combo1, KC_Q), COMBO(unique_combo2, KC_J), };

** stuff
Here we take everything from the section before and format these accordingly before taking everything together.
*** header
#+name: header
#+begin_src C :main no :tangle no :results none
/* vim:ro
 * -*- buffer-read-only: t -*-
 *
 * This is autogenerated using doom/org-tangle DO NOT EDIT.
 * Please refer to main.org in [[https://git.sr.ht/~jat/keymaps]]
 *
 *
 * Copyright 2021 Freja
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#+end_src

*** matrix stuff
#+name: keymap
#+begin_src C :main no :tangle no :noweb yes :results none
enum layers {
    _base = 0,
    _game,
    _low,
    _high,
    _adj,
};

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
         [_base] = LAYOUT(<<generate-layer(input=base_layout)>>),
         [_game] = LAYOUT(<<generate-layer(input=game_layout)>>),
         [_low] = LAYOUT(<<generate-layer(input=low_layout)>>),
         [_high] = LAYOUT(<<generate-layer(input=high_layout)>>),
         [_adj] = LAYOUT(<<generate-layer(input=adj_layout)>>),
};
#+end_src

*** combo stuff
#+name: combo
#+begin_src C :main no :noweb yes :result none
<<generate-combosequence()>>
<<generate-combocombination()>>
#+end_src
** putting it all together
*** keymap.c
#+begin_src C :noweb yes :tangle keymap.c :results none :no-expand
<<header>>

#include QMK_KEYBOARD_H

<<keymap>>

#ifdef ENCODER_ENABLE
<<encoder>>
#endif

<<combo>>
#+end_src

*** config.h
#+begin_src C :noweb yes :tangle config.h :results none :no-expand
<<header>>

#pragma once

#define EE_HANDS

#define LAYER_STATE_8BIT

#define TAPPING_TERM 300
#define IGNORE_MOD_TAP_INTERRUPT

#ifdef OLED_DRIVER_ENABLE
#define OLED_DISPLAY_128X64
#endif

#ifdef NKRO_ENABLE
#define FORCE_NKRO
#endif

#ifdef RGBLIGHT_ENABLE
#define RGBLIGHT_LED_MAP {0,1,2,9,8,7,4,3,5,6,19,18,17,10,11,12,15,16,14,13}
#define RGBLIGHT_SLEEP
#define RGBLIGHT_EFFECT_BREATHING
#define RGBLIGHT_EFFECT_KNIGHT

#define RGBLIGHT_HUE_STEP 8
#define RGBLIGHT_SAT_STEP 8
#define RGBLIGHT_VAL_STEP 8
#define RGBLIGHT_LIMIT_VAL 150
#endif

#ifdef ENCODER_ENABLE
#define ENCODER_RESOLUTION 2
#define ENCODER_DIRECTION_FLIP
#endif

#ifdef COMBO_ENABLE
#define COMBO_COUNT <<get-combocount()>>
#endif

// define USB_POLLING_INTERVAL_MS 5
#+end_src

*** rules.mk
#+begin_src C :tangle rules.mk :noweb yes :results none :no-expand
OLED_DRIVER_ENABLE = no
WPM_ENABLE = no
RGBLIGHT_ENABLE = yes
NKRO_ENABLE = yes
COMBO_ENABLE = <<combo-enable()>>
ENCODER_ENABLE = yes

BOOTLOADER=qmk-hid
BOOTLOADER_SIZE=512
#+end_src
