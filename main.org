#+title: keymaps
#+author: Freja
#+startup: content

* The keymap
** The layout
I primarily type in German, English and Swedish so the keyboard should be cabable or outputing the used characters like ~ü~ or ~å~.
For that I am using [[https://eurkey.steffen.bruentjen.eu/][EurKey]] - but US Intl should be fine too - on my system.  These are QWERTY layouts but they are able to output letters used in different languages using Alt Gr aka Right Alt.

*** Base layer
On the keyboard however I will use a modified version of [[https://sites.google.com/alanreiser.com/handsdown/home?authuser=0#h.rt23wndkh65l][hands down gold]], until something better comes up.
#+name: base_layout
| &nop | &kp k      | &kp f      | &kp m      | &kp p      | &kp v   |            |          |           |                 | &kp semi  | &kp dot    | &kp fslh   | &kp sqt    | &kp equal  | &nop |
| &nop | &mt lgui r | &mt lalt s | &mt lsft n | &mt lctl d | &kp w   |            |          |           |                 | &kp comma | &mt rctl a | &mt rsft e | &mt lalt o | &mt rgui i | &nop |
| &nop | &kp x      | &kp q      | &kp l      | &kp c      | &kp b   | &mo _adj   | &kp gesc | &tg _game | &nop            | &kp minus | &kp h      | &kp u      | &kp z      | &kp k      | &nop |
|      |            |            | &kp lgui   | &kp tab    | &kp del | &lt _low t | &kp ret  | &kp ralt  | &lt _high space | &kp bspc  | &nop       | &kp mute   |            |            |      |

*** g*ming layout
Too lazy to config shit in every game I use a keyboard with.
#+name: game_layout
| &nop | &kp a | &kp w | &kp e    | &kp r   | &kp t    |                |          |           |      | &nop   | &nop   | &kp n3   | &kp n4 | &nop   | &nop |
| &nop | &kp q | &kp s | &kp d    | &kp f   | &kp g    |                |          |           |      | &kp n7 | &kp n1 | &kp n2   | &kp n5 | &kp n6 | &nop |
| &nop | &kp z | &kp x | &kp c    | &kp v   | &kp b    | &kp lsft       | &kp gesc | &tg _game | &nop | &nop   | &nop   | &nop     | &nop   | &nop   | &nop |
|      |       |       | &kp lgui | &kp tab | &kp lalt | &lt _low space | &kp ret  | &nop      | &nop | &nop   | &nop   | &kp mute |        |        |      |

*** lower layer
#+name: low_layout
| &nop | &kp n1 | &kp n2   | &kp n3   | &kp n4   | &kp n5 |       |       |       |       | &kps n1 | &kps n2   | &kps n3   | &kps n4   | &kps n5 | &nop |
| &nop | &kp n6 | &kp n7   | &kp n8   | &kp n9   | &kp n0 |       |       |       |       | &kps n6 | &kps n7   | &kps n8   | &kps n9   | &kps n0 | &nop |
| &nop | &trns  | &kp bslh | &kp lbrc | &kp rbrc | &trns  | &trns | &trns | &trns | &trns | &trns   | &kps lbrc | &kps rbrc | &kps bslh | &trns   | &nop |
|      |        |          | &trns    | &trns    | &trns  | &trns | &trns | &trns | &trns | &trns   | &trns     | &trns     |           |         |      |

*** raise layer
#+name: high_layout
| &nop | &trns    | &kp volu | &trns    | &trns     | &trns    |       |       |       |       | &trns    | &trns    | &trns  | &trns     | &trns | &nop |
| &nop | &trns    | &kp vold | &kp prev | &kp pause | &kp next |       |       |       |       | &kp left | &kp down | &kp up | &kp right | &trns | &nop |
| &nop | &kp undo | &kp cut  | &kp copy | &kp paste | &trns    | &trns | &trns | &trns | &trns | &trns    | &trns    | &trns  | &trns     | &trns | &nop |
|      |          |          | &trns    | &trns     | &trns    | &trns | &trns | &trns | &trns | &trns    | &trns    | &trns  |           |       |      |

*** adjusting shit
This layer contains stuff for adjusting, be it ~EE_HANDS~ or rgb stuff.
#+name: adj_layout
| &nop | &kp eelh  | &kp eerh  | &nop | &nop | &nop |       |      |      |      | &nop | &kp rgbhu | &kp rgbsu | &kp rgbvu | &kp rgbmu | &nop |
| &nop | &nop      | &nop      | &nop | &nop | &nop |       |      |      |      | &nop | &kp rgbhd | &kp rgbsd | &kp rgbvd | &kp rgbmd | &nop |
| &nop | &kp reset | &kp eeprt | &nop | &nop | &nop | &trns | &nop | &nop | &nop | &nop | &nop      | &nop      | &nop      | &nop      | &nop |
|      |           |           | &nop | &nop | &nop | &nop  | &nop | &nop | &nop | &nop | &nop      | &nop      |           |           |      |
** combos
Here, combos are a nice feature allowing to add keys at places where they don't impear your typing yet are comfortable to use.
#+name: combo-table
| result | chord |   |
| y      | k     | f |
| q      | m     | p |

** encoder
Rotary encoders add a lot of features and functionality, they are extremly useful.
For me, I like to have volume control on one side and window control on the other.

Simple structure is the function ~encoder_update_user(index, clockwise)~, this runs a simple /this encoder does this when turned clockwise, this then otherwise/.
#+name: encoder
#+begin_src C :main no :tangle no :results none
bool is_alt_tab = false;
uint16_t alt_tab_timer = 0;

bool encoder_update_user(uint8_t index, bool clockwise) {
    if (index == 1) {
        if (clockwise) {
            tap_code(KC_VOLU);
        } else {
            tap_code(KC_VOLD);
        }
    } else if (index == 0) {
        if (!clockwise) {
            if (!is_alt_tab) {
                is_alt_tab = true;
                register_code(KC_LALT);
            }
            alt_tab_timer = timer_read();
            tap_code16(KC_TAB);
        } else {
            if (!is_alt_tab) {
                is_alt_tab = true;
                register_code(KC_LALT);
            }
            alt_tab_timer = timer_read();
            tap_code16(S(KC_TAB));
        }
    }

    return false;
}

void matrix_scan_user(void) {
    if (is_alt_tab) {
        if (timer_elapsed(alt_tab_timer) > 800) {
            unregister_code(KC_LALT);
            is_alt_tab = false;
        }
    }
}
#+end_src


* Abandon all hope, ye who enter here
This section is the build section. from this point on it's code and code only, be it elisp or c.
I would not recommend altering anything up there, escpecially the generator code, unless you know what you are doing.

I try to write it fairly pessimistic, but if anything faulty goes through, qmk will complain about it.
** generators and parser
*** layers
#+name: generate-layer
#+begin_src elisp :var input=adj_layout keycode=keycode_table modcode=mod_table :results value
(defun get-keycode (name)
  "Returns the keycode if it exists."
  (let ((code (nth 1 (assoc name keycode))))
    (if (not code)
        (error "The key %s does't exist - yet." name)
        code)))

(defun get-mod (name)
  "Returns the mod if it exists."
  (let ((code (nth 1 (assoc name modcode))))
    (if (not code)
        (error "The mod %s does't exist." name)
        code)))

(setq input (flatten-tree input) ; flat is justice
      result "")

(unless (eq (length input) 64)
  (error "Either you use a different keyboard with a different matrix, or you missed a col or two, it's %d long instead of 64 long" (length input)))

(while input
  (let ((word (pop input)))
    (unless (eq word "")
      (let* ((expr (split-string word))
             (pre (car expr)))
        ;(print expr)
        (pcase pre
          ("&nop"       (setq result (concat result "XXXXXXX, ")))
          ("&trns"      (setq result (concat result "_______, ")))
          ("&kp"  ; normal keycode
            (let ((key (get-keycode (nth 1 expr))))
              (setq result (concat result key ", "))))
          ("&kps"  ; shifted keycode
            (let ((key (get-keycode (nth 1 expr))))
              (setq result (concat result (format "S(%s), " key)))))
          ("&tg"  ; toggle layer
            (let ((layer (nth 1 expr)))
              (setq result (concat result (format "TG(%s), " layer)))))
          ("&lt"  ; layer tap
            (let ((layer (nth 1 expr))
                  (key (get-keycode (nth 2 expr))))
              (setq result (concat result (format "LT(%s, %s), " layer key)))))
          ("&mo"  ; layer hold
            (let ((layer (nth 1 expr)))
              (setq result (concat result (format "MO(%s), " layer)))))
          ("&mt"  ; mod tap
            (let ((modkey (get-mod (nth 1 expr)))
                  (key (get-keycode (nth 2 expr))))
              (setq result (concat result (format "MT(%s, %s), " modkey key)))))
          (any  ; unknown key
           (let ((x (% (1+ (length input)) 16))
                 (y (1+ (/ (length input) 16))))
             (error "Unknown key %s at %d:%d" any x y))))))))

(substring result 0 -2)  ; cutting of the last ", "
;(s-chop-suffix ", " result) <- doesn't work outside emacs
#+end_src

#+RESULTS: generate-layer
: XXXXXXX, EH_LEFT, EH_RGHT, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, RGB_HUI, RGB_SAI, RGB_VAI, RGB_MOD, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, RGB_HUD, RGB_SAD, RGB_VAD, RGB_RMOD, XXXXXXX, XXXXXXX, RESET, EEP_RST, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, _______, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX

*** combos
#+name: get-combocount
#+begin_src elisp :main no :var in=combo-table :result value
(length in)
#+end_src

#+name: generate-combosequence
#+begin_src elisp :main no :var in=combo-table keycode=keycode_table :result value
(defun get-keycode (name)
  "Returns the keycode if it exists."
  (let ((code (nth 1 (assoc name keycode))))
    (if (not code)
        (error "The key %s in the combo doesn't exist" name)
        code)))

(setq result ""
      id 0  ; too lazy to create names, I just use a running number
      in (cdr in))  ; get the cdr since the first row is purely descriptive

(while in
  (setq row (pop in))
  (setq result (concat result (format "const uint16_t PROGMEM unique_combo%d[] = { " id)))
  (while (cdr row)
    (let ((key (pop (cdr row))))
      (setq result (concat result (get-keycode key) ", "))))
  (setq result (concat result "COMBO_END, };\n"))
  (setq id (1+ id)))

(print result)
#+end_src

#+RESULTS: generate-combosequence
: const uint16_t PROGMEM unique_combo0[] = { KC_K, KC_F, COMBO_END, };
: const uint16_t PROGMEM unique_combo1[] = { KC_M, KC_P, COMBO_END, };

#+name: generate-combocombination
#+begin_src elisp :main no :var in=combo-table keycode=keycode_table :result value
(defun get-keycode (name)
  "Returns the keycode if it exists."
  (let ((code (nth 1 (assoc name keycode))))
    (if (not code)
        (error "The key %s in the combo doesn't exist" name)
        code)))

(setq result "combo_t key_combos[COMBO_COUNT] = { "
      id 0
      in (cdr in))  ; discard the first row

(while in
  (setq key (car (pop in))
        result (concat result (format "COMBO(unique_combo%d, %s), " id (get-keycode key)))
        id (1+ id)))

(concat result "};")
#+end_src

#+RESULTS: generate-combocombination
: combo_t key_combos[COMBO_COUNT] = { 'COMBO(unique_combo0, KC_Y), COMBO(unique_combo1, KC_Q), };


** stuff
this section just contains data, be it snippets or tables for translations
*** keycodes
A not so complete list of keycodes
#+name: keycode_table
| a     | KC_A      |
| b     | KC_B      |
| c     | KC_C      |
| d     | KC_D      |
| e     | KC_E      |
| f     | KC_F      |
| g     | KC_G      |
| h     | KC_H      |
| i     | KC_I      |
| j     | KC_J      |
| k     | KC_K      |
| l     | KC_L      |
| m     | KC_M      |
| n     | KC_N      |
| o     | KC_O      |
| p     | KC_P      |
| q     | KC_Q      |
| r     | KC_R      |
| s     | KC_S      |
| t     | KC_T      |
| u     | KC_U      |
| v     | KC_V      |
| w     | KC_W      |
| x     | KC_X      |
| y     | KC_Y      |
| z     | KC_Z      |
| n1    | KC_1      |
| n2    | KC_2      |
| n3    | KC_3      |
| n4    | KC_4      |
| n5    | KC_5      |
| n6    | KC_6      |
| n7    | KC_7      |
| n8    | KC_8      |
| n9    | KC_9      |
| n0    | KC_0      |
| ret   | KC_ENTER  |
| esc   | KC_ESC    |
| gesc  | KC_GESC   |
| bspc  | KC_BSPACE |
| del   | KC_DEL    |
| tab   | KC_TAB    |
| space | KC_SPACE  |
| minus | KC_MINUS  |
| equal | KC_EQUAL  |
| lbrc  | KC_LBRC   |
| rbrc  | KC_RBRC   |
| fslh  | KC_SLASH  |
| bslh  | KC_BSLASH |
| semi  | KC_SCOLON |
| dot   | KC_DOT    |
| comma | KC_COMMA  |
| sqt   | KC_QUOTE  |
| grave | KC_GRAVE  |
| lsft  | KC_LSHIFT |
| rsft  | KC_RSHIFT |
| lctl  | KC_LCTRL  |
| rctl  | KC_RCTRL  |
| lalt  | KC_LALT   |
| ralt  | KC_RALT   |
| lgui  | KC_LGUI   |
| rgui  | KC_RGUI   |
| mute  | KC_MUTE   |
| left  | KC_LEFT   |
| down  | KC_DOWN   |
| up    | KC_UP     |
| right | KC_RIGHT  |
| volu  | KC_VOLU   |
| vold  | KC_VOLD   |
| pause | KC_MPLY   |
| next  | KC_MNXT   |
| prev  | KC_MPRV   |
| undo  | KC_UNDO   |
| cut   | KC_CUT    |
| copy  | KC_COPY   |
| paste | KC_PASTE  |
| eelh  | EH_LEFT   |
| eerh  | EH_RGHT   |
| rgbhu | RGB_HUI   |
| rgbhd | RGB_HUD   |
| rgbsu | RGB_SAI   |
| rgbsd | RGB_SAD   |
| rgbvu | RGB_VAI   |
| rgbvd | RGB_VAD   |
| rgbmu | RGB_MOD   |
| rgbmd | RGB_RMOD  |
| reset | RESET     |
| eeprt | EEP_RST   |

A semi complete list of modifier codes
#+name: mod_table
| lsft | MOD_LSFT |
| rsft | MOD_RSFT |
| lctl | MOD_LCTL |
| rctl | MOD_RCTL |
| lalt | MOD_LALT |
| ralt | MOD_RALT |
| lgui | MOD_LGUI |
| rgui | MOD_RGUI |

*** header
#+name: header
#+begin_src C :main no :tangle no :results none
/* vim:ro
 * -*- buffer-read-only: t -*-
 *
 * This is autogenerated using doom/org-tangle DO NOT EDIT.
 * Please refer to main.org in [[https://git.sr.ht/~jat/keymaps]]
 *
 *
 * Copyright 2021 Freja
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#+end_src

*** matrix stuff
#+name: keymap
#+begin_src C :main no :tangle no :noweb yes :results none
enum layers {
    _base = 0,
    _game,
    _low,
    _high,
    _adj,
};

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
         [_base] = LAYOUT(<<generate-layer(input=base_layout)>>),
         [_game] = LAYOUT(<<generate-layer(input=game_layout)>>),
         [_low] = LAYOUT(<<generate-layer(input=low_layout)>>),
         [_high] = LAYOUT(<<generate-layer(input=high_layout)>>),
         [_adj] = LAYOUT(<<generate-layer(input=adj_layout)>>),
};
#+end_src

*** combo stuff
#+name: combo
#+begin_src C :main no :noweb yes :result none
<<generate-combosequence()>>
<<generate-combocombination()>>
#+end_src
** putting it all together
*** keymap.c
#+begin_src C :noweb yes :tangle keymap.c
<<header>>

#include QMK_KEYBOARD_H

<<keymap>>

#ifdef ENCODER_ENABLE
<<encoder>>
#endif

#ifdef COMBO_ENABLE
<<combo>>
#endif
#+end_src

*** config
#+begin_src C :noweb yes :tangle config.h
<<header>>

#pragma once

#define EE_HANDS

#define TAPPING_TERM 350
#define IGNORE_MOD_TAP_INTERRUPT

#ifdef OLED_DRIVER_ENABLE
#define OLED_DISPLAY_128X64
#endif

#ifdef NKRO_ENABLE
#define FORCE_NKRO
#endif

#ifdef RGBLIGHT_ENABLE
#define RGBLIGHT_SLEEP
#define RGBLIGHT_EFFECT_BREATHING
#define RGBLIGHT_EFFECT_KNIGHT


#define RGBLIGHT_HUE_STEP 8
#define RGBLIGHT_SAT_STEP 8
#define RGBLIGHT_VAL_STEP 8
#define RGBLIGHT_LIMIT_VAL 150
#endif

#ifdef ENCODER_ENABLE
#define ENCODER_RESOLUTION 2
#define ENCODER_DIRECTION_FLIP
#endif

#ifdef COMBO_ENABLE
#define COMBO_COUNT <<get-combocount()>>
#endif

// define USB_POLLING_INTERVAL_MS 5
#+end_src

*** rules
#+begin_src C :tangle rules.mk :results none
OLED_DRIVER_ENABLE = no
RGBLIGHT_ENABLE = yes
NKRO_ENABLE = yes
COMBO_ENABLE = yes
ENCODER_ENABLE = yes

BOOTLOADER=qmk-hid
BOOTLOADER_SIZE=512
#+end_src
