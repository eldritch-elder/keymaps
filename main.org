#+title: keymap
#+author: Freja 'jat
#+startup: content

* The keymap
** The layout
*** Base layer
#+name: base_layer
| xxx   | xxx   | &kp f | &kp m      | &kp p | &kp v   | &kp semi  | &kp dot   | &kp fslh   | &kp sqt | xxx   | &kp ralt  |
| &kp z | &kp r | &kp s | &kp n      | &kp d | &kp w   | &kp comma | &kp a     | &kp e      | &kp i   | &kp o | &kp equal |
|       | &kp x | &kp g | &kp l      | &kp c | &kp b   | &kp minus | &kp h     | &kp u      | &kp y   | &kp k |           |
|       |       |       | &mo _lower | &kp t | &kp ret | &kp tab   | &kp space | &mo _raise |         |       |           |

*** qwerty
if i ever need qwerty for no reason whatsoever
#+name: qwerty_layer
| xxx | &kp q | &kp w | &kp e      | &kp r | &kp t   | &kp y     | &kp u     | &kp i      | &kp o | &kp p | xxx |
| xxx | &kp r | &kp s | &kp n      | &kp d | &kp w   | &kp comma | &kp a     | &kp e      | &kp i | &kp o | xxx |
|     | &kp x | &kp g | &kp l      | &kp c | &kp b   | &kp minus | &kp h     | &kp u      | &kp y | &kp k |     |
|     |       |       | &mo _lower | &kp t | &kp ret | &kp lsft  | &kp space | &mo _raise |       |       |     |

*** artsey.io
#+name: artseyio_layer
| xxx | &kp s | &kp t | &kp r | &kp a | xxx | xxx | xxx | xxx      | xxx | xxx | xxx |
| xxx | &kp o | &kp i | &kp y | &kp e | xxx | xxx | xxx | xxx      | xxx | xxx | xxx |
|     | xxx   | xxx   | xxx   | xxx   | xxx | xxx | xxx | xxx      | xxx | xxx |     |
|     |       |       | xxx   | xxx   | xxx | xxx | xxx | &mo _adj |     |     |     |

#+name: artseyio_table
| &kp b     | 13 | 16 |    |    |
| &kp c     | 15 | 16 |    |    |
| &kp d     |  2 |  3 |  4 |    |
| &kp f     |  3 |  4 |    |    |
| &kp g     |  2 |  3 |    |    |
| &kp h     | 14 | 16 |    |    |
| &kp j     |  1 |  2 |    |    |
| &kp k     | 13 | 15 |    |    |
| &kp l     | 14 | 15 | 16 |    |
| &kp m     | 13 | 14 | 15 |    |
| &kp n     | 13 | 14 |    |    |
| &kp p     | 13 | 14 | 16 |    |
| &kp q     |  1 |  2 |  4 |    |
| &kp u     | 14 | 15 |    |    |
| &kp v     |  1 |  3 |    |    |
| &kp w     |  1 |  4 |    |    |
| &kp x     |  1 |  2 |  3 |    |
| &kp z     |  1 |  2 |  3 |  4 |
| &kp sqt   | 14 | 15 |  4 |    |
| &kp dot   | 15 |  4 |    |    |
| &kp comma | 14 |  4 |    |    |
| &kp fslh  | 13 |  4 |    |    |
| &kp space | 13 | 14 | 15 | 16 |
| &kp ret   |  4 | 16 |    |    |
| &kp esc   | 13 |  3 |  4 |    |
| &osm lsft |  1 |  2 |  3 | 16 |
| &osm lctl |  1 | 16 |    |    |
| &osm lalt |  1 | 14 |    |    |
| &osm lgui |  1 | 15 |    |    |
| &kp caps  | 13 | 14 | 15 |  4 |

*** lower layer
#+name: low_layer
| --- | &kp n1 | &kp n2 | &kp n3 | &kp n4 | &kp n5 | &kps n1 | &kps n2 | &kps n3 | &kps n4 | &kps n5 | --- |
| --- | &kp n6 | &kp n7 | &kp n8 | &kp n9 | &kp n0 | &kps n6 | &kps n7 | &kps n8 | &kps n9 | &kps n0 | --- |
|     | ---    | ---    | ---    | ---    | ---    | ---     | ---     | ---     | ---     | ---     |     |
|     |        |        | ---    | ---    | ---    | ---     | ---     | ---     |         |         |     |

*** raise layer
#+name: high_layer
| --- | &kp print | --- | --- | --- | --- | &kp prev | &kp pause | &kp next | ---       | --- | --- |
| --- | ---       | --- | --- | --- | --- | &kp left | &kp down  | &kp up   | &kp right | --- | --- |
|     | ---       | --- | --- | --- | --- | ---      | ---       | ---      | ---       | --- |     |
|     |           |     | --- | --- | --- | &mo _adj | ---       | ---      |           |     |     |

*** adjusting shit
#+name: adj_layer
| &rgb RGB_HUI | &rgb RGB_SAI | &rgb RGB_BRI | xxx         | xxx              | xxx | xxx | xxx | xxx | xxx | xxx | &rgb RGB_ON  |
| &rgb RGB_HUD | &rgb RGB_SAD | &rgb RGB_BRD | xxx         | xxx              | xxx | xxx | xxx | xxx | xxx | xxx | &rgb RGB_OFF |
|              | xxx          | xxx          | xxx         | xxx              | xxx | xxx | xxx | xxx | xxx | xxx |              |
|              |              |              | &any &reset | &any &bootloader | xxx | xxx | xxx | xxx |     |     |              |

** combos
Since i'm defining combos using the positions they are all based on the base layer making them independent of the active layer.
#+name: combo-table
| &kp lbrc        |  3 | 16 |    |
| &kp lbkt        | 14 | 16 |    |
| &kp rbkt        | 19 | 21 |    |
| &kp rbrc        | 19 |  8 |    |
| &kp q           |  1 |  2 |    |
| &kp j           |  3 |  4 |    |
| &kpag a         | 25 | 27 |    |
| &kpag u         | 30 | 32 |    |
| &kpag o         | 30 | 33 |    |
| &osm lsft       |  8 |  9 |    |
| &osm lctl       | 25 | 26 |    |
| &osm lalt       | 31 | 32 |    |
| &any &caps_word |  4 |  7 |    |
| &kp esc         | 13 | 16 |    |
| &kp tab         |  2 |  3 |    |
| &kp bspc        | 19 | 20 |    |
| &kpc bspc       | 19 | 20 | 21 |
| &kps n1         |  2 |  3 | 16 |
| &kps fslh       | 14 | 15 |  4 |
| &kp bslh        | 12 | 16 |    |
| &kp grave       |  9 | 10 |    |
| &kps grave      | 32 | 33 |    |
| &kps sqt        |  7 | 10 |    |
| &kps semi       |  6 |  7 |    |
| &kps n9         |  2 | 16 |    |
| &kps n0         | 19 |  9 |    |
| &kps equal      | 29 | 30 |    |

| &SS ":kuzco_nice:"        | 3 | 43 |    |    |
| &ss ":BerucaPervert:"     | 1 | 43 |    |    |
| &ss ":hundi_kek:"         | 2 | 43 |    |    |
| &ss ":rainbow::rainbow2:" | 4 | 43 |    |    |

Heres a table with the positions for reference:
|  0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |  8 |  9 | 10 | 11 |
| 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 |
|    | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 32 | 33 |    |
|    |    |    | 34 | 35 | 36 | 37 | 38 | 39 |    |    |    |

** encoder

* Abandon all hope, ye who enter here
This section is the build section. From this point on it's code and code only.
I would not recommend altering anything down there, escpecially the generator code, unless you know what you are doing.

I try to write it fairly pessimistic, but if anything faulty goes through, zmk will complain about it.

** generators and parser
This section contains stuff used for parsing the key definitions.

*** keycodes
#+name: keycode-parsing
#+begin_src elisp :results none
(defun get-keycode (name)
  "Returns the keycode if it exists."
  (let ((code (nth 1 (assoc name keycode))))
    (if (not code)
        (error "The key %s does't exist - yet." name)
        code)))

(defun get-mod (name)
  "Returns the mod if it exists."
  (let ((code (nth 1 (assoc name modcode))))
    (if (not code)
        (error "The mod %s does't exist." name)
        code)))

(defun parse-key (word)
  "Parses the expression and returns the keycode."
    (pcase word
      ((or "&nop" "xxx")                                                                          "&none")
      ((or "&trns" "___" "---")                                                                   "&trans")
      ((rx bos "&kp" (+ space) (let head (+ word)) (* space) eos)                                 (format "&kp %s" (get-keycode head)))
      ((rx bos "&kps" (+ space) (let head (+ word)) (* space) eos)                                (format "&kp LS(%s)" (get-keycode head)))
      ((rx bos "&kpc" (+ space) (let head (+ word)) (* space) eos)                                (format "&kp LC(%s)" (get-keycode head)))
      ((rx bos "&kpa" (+ space) (let head (+ word)) (* space) eos)                                (format "&kp LA(%s)" (get-keycode head)))
      ((rx bos "&kpag" (+ space) (let head (+ word)) (* space) eos)                               (format "&kp RA(%s)" (get-keycode head)))
      ((rx bos "&kpg" (+ space) (let head (+ word)) (* space) eos)                                (format "&kp LG(%s)" (get-keycode head)))
      ((rx bos "&tg" (+ space) (let head (+ word)) (* space) eos)                                 (format "&tog %s" head))
      ((rx bos "&lt" (+ space) (let arg (+ word)) (+ space) (let head (+ word)) (* space) eos)    (format "&lt %s %s" arg (get-keycode head)))
      ((rx bos "&mo" (+ space) (let head (+ word)) (* space) eos)                                 (format "&mo %s" head))
      ((rx bos "&mt" (+ space) (let arg (+ word)) (+ space) (let head (+ word)) (* space) eos)    (format "&mt %s %s" (get-mod arg) (get-keycode head)))
      ((rx bos "&osm" (+ space) (let head (+ word)) (* space) eos)                                (format "&sk %s" (get-mod head)))
      ((rx bos "&rgb" (+ space) (let head (+ anychar)) (* space) eos)                                (format "&rgb_ug %s" head))
      ((rx bos "&any" (+ space) (let head (* anychar) eos))                                       (format "%s" head))
      (-                                                                                          (error "unknown expr `%s`" word))))
#+end_src

**** tables n shit
A not so complete list of keycodes
#+name: keycode_table
| a       | A             |
| b       | B             |
| c       | C             |
| d       | D             |
| e       | E             |
| f       | F             |
| g       | G             |
| h       | H             |
| i       | I             |
| j       | J             |
| k       | K             |
| l       | L             |
| m       | M             |
| n       | N             |
| o       | O             |
| p       | P             |
| q       | Q             |
| r       | R             |
| s       | S             |
| t       | T             |
| u       | U             |
| v       | V             |
| w       | W             |
| x       | X             |
| y       | Y             |
| z       | Z             |
| n1      | N1            |
| n2      | N2            |
| n3      | N3            |
| n4      | N4            |
| n5      | N5            |
| n6      | N6            |
| n7      | N7            |
| n8      | N8            |
| n9      | N9            |
| n0      | N0            |
| ret     | RETURN        |
| esc     | ESCAPE        |
| bspc    | BACKSPACE     |
| del     | DELETE        |
| tab     | TAB           |
| space   | SPACE         |
| minus   | MINUS         |
| equal   | EQUAL         |
| lbkt    | LEFT_BRACKET  |
| rbkt    | RIGHT_BRACKET |
| lbrc    | LEFT_BRACE    |
| rbrc    | RIGHT_BRACE   |
| fslh    | SLASH         |
| bslh    | BACKSLASH     |
| semi    | SEMI          |
| dot     | DOT           |
| comma   | COMMA         |
| sqt     | SQT           |
| grave   | GRAVE         |
| lsft    | LEFT_SHIFT    |
| rsft    | RIGHT_SHIFT   |
| lctl    | LEFT_CONTROL  |
| rctl    | RIGHT_CONTROL |
| lalt    | LEFT_ALT      |
| ralt    | RIGHT_ALT     |
| lgui    | LEFT_GUI      |
| rgui    | RIGHT_GUI     |
| caps    | CAPSLOCK      |
| left    | LEFT          |
| down    | DOWN          |
| up      | UP            |
| right   | RIGHT         |
| mute    | C_MUTE        |
| volu    | C_VOL_UP      |
| vold    | C_VOL_DN      |
| pause   | C_PLAY_PAUSE  |
| next    | C_NEXT        |
| prev    | C_PREV        |
| print   | PRINTSCREEN   |

A semi complete list of modifier codes
#+name: mod_table
| lsft  | LEFT_SHIFT    |
| rsft  | RIGHT_SHIFT   |
| lctl  | LEFT_CONTROL  |
| rctl  | RIGHT_CONTROL |
| lalt  | LEFT_ALT      |
| ralt  | RIGHT_ALT     |
| lgui  | LEFT_GUI      |
| rgui  | RIGHT_GUI     |

*** layers
For processing the table and generating the layers
#+name: generate-layer
#+begin_src elisp :var input=base_layer keycode=keycode_table modcode=mod_table :noweb yes :results value drawer
<<keycode-parsing>>

(setq input (remove "" (flatten-tree input)) ; flat is justice
      result "<")

((lambda (foo x)
 (let ((ln (length foo)))
   (unless (eq x ln) (error "missing key in layer; required %d, found %d" x ln))))
 input 40)

(while input
  (let ((word (pop input)))
    (setq result (concat result (parse-key word) " "))))

(concat result ">")
#+end_src

*** combos
Parsing and generating the code for the combos
#+name: generate-combos
#+begin_src elisp :main no :noweb yes :var in=combo-table keycode=keycode_table modcode=mod_table :result value drawer
<<keycode-parsing>>

(setq result ""
      id 0) ; using a running number for naming the combos

;; check if the combos ain't empty or something
(mapcar (lambda (x)
          (let ((event (car x))
                (tail (nth 2 x)))
            (if (eq event "") (error "events are required in combos, abort"))
            (if (eq tail "") (error "combo for `%s` seems to be empty, abort" event))))
        in)

(while in
  (let* ((row (pop in))
         (event (parse-key (car row)))
         (pos ((lambda (x) (string-trim (format "%s" x) "(" ")")) (remove "" (cdr row))))) ; FIXME awful hack
         ;(pos (mapconcat 'identity (nthcdr 2 row) " "))) ; doesn't work for some reason
    ; TODO make timeout dynamically adjustable
    (setq result (concat result (format "\nunique_combo%d { timeout-ms = <%d>; key-positions = <%s>; bindings = <%s>; };"
            id 50 pos event))
          id (1+ id))))

(print result)
#+end_src

** stuff
Here we take everything from the section before and format these accordingly before taking everything together.
*** header
#+name: header
#+begin_src dts :main no :tangle no :results none
/* -*- buffer-read-only: t -*-
 * vim:ro
 *
 * This is autogenerated using babel DO NOT EDIT.
 * Please refer to main.org in [[https://git.sr.ht/~jat/keymap]]
 */
#+end_src

*** matrix stuff
#+name: keymap
#+begin_src dts :main no :tangle no :noweb yes :results drawer
keymap {
    compatible = "zmk,keymap";

    #define _base 0
    #define _lower 1
    #define _raise 2
    #define _adj 3

    base_layer {
        bindings = <<generate-layer(input=base_layer)>>;
        sensor-bindings = <&inc_dec_kp C_VOL_DN C_VOL_UP>;
    };

    lower_layer {
        bindings = <<generate-layer(input=low_layer)>>;
    };

    raise_layer {
        bindings = <<generate-layer(input=high_layer)>>;
    };

    adjust_layer {
        bindings = <<generate-layer(input=adj_layer)>>;
    };
}
#+end_src

*** combo stuff
#+name: combo
#+begin_src dts :main no :noweb yes :results none
combos {
    compatible = "zmk,combos";
    <<generate-combos()>>
}
#+end_src

*** osm stuff
#+name: osm
#+begin_src dts :results none
&sk {
    quick-release;
};
#+end_src

*** caps word
#+name: caps-word
#+begin_src dts :main no :results none
&caps_word {
    continue-list = <UNDERSCORE MINUS BSPC LSHFT RSHFT>;
};
#+end_src
** putting it all together
*** splaytoraid40.keymap
#+begin_src dts :main no :tangle config/splaytoraid40.keymap :noweb yes :no-expand :results none
<<header>>

#include <behaviors.dtsi>
#include <dt-bindings/zmk/keys.h>
#include <dt-bindings/zmk/rgb.h>

<<osm>>
<<caps-word>>

/ {
    <<combo>>;

    <<keymap>>;
};
#+end_src

*** splaytoraid40.conf
#+begin_src conf :main no :tangle config/splaytoraid40.conf :noweb yes :noexpand :results none
CONFIG_ZMK_USB_LOGGING=n

CONFIG_ZMK_IDLE_TIMEOUT=1800000 # 30'

# CONFIG_ZMK_KSCAN_DEBOUNCE_PRESS_MS=7
# CONFIG_ZMK_KSCAN_DEBOUNCE_RELEASE_MS=7

CONFIG_ZMK_COMBO_MAX_COMBOS_PER_KEY=80

CONFIG_ZMK_RGB_UNDERGLOW_HUE_STEP=1
CONFIG_ZMK_RGB_UNDERGLOW_SAT_STEP=1
CONFIG_ZMK_RGB_UNDERGLOW_BRT_STEP=5
CONFIG_ZMK_RGB_UNDERGLOW_AUTO_OFF_IDLE=y # i often leave my pc powered on
#+end_src
