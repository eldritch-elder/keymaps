#+title: keymaps
#+author: Freja

* Pre-stuff
** keymaps?
Yes, keymaps, QWERTY is boring and as someone who writes a lot on their keyboard, I wanted to spice up the game and use a better suited layout so I tried colemak.
Well, after a year or so, here I am, on my kyria, writing in hands down and thinking about trying out stenotype.
This document is intended to 1. *document* (pun intended) and 2. to generate working keymap files through literate programming for ~qmk~ and maybe even ~kmonad~ and ~zmk~, who knows what the future will bring up.
Maybe I'll go even more bollocks and write my stenolibrary i-- although, no, let's not do that.

** literate programming?
Literate programming is basically generating stuff using src code blocks in an markup/outline document.
This approach takes documentation extremly to the front and makes it easy to completely restructure the source and do my own stuff.
I can write code here which generates stuff which is used to generate stuff, it's very powerful and very convinient.
Simply said, this makes reading source like reading a book.
When I first started to go /deep/ into the abyss, I was shocked how some people just ignore documentation and make it a big mess, how some are using macros extensivelly which are defined /somewhere/ in ~users/~ and I wanted to do better.
I try to explain everything and make everything very clearly visible.
I kinda try to make it very automatic, so that you in the end only need to edit the [[*The keymap][data]] and you just need to tangle those using something like [[https://github.com/hlissner/doom-emacs/blob/develop/bin/org-tangle][this script]].
Some things like the filenames and the keyboard matrix are hardcoded and you need to go through the [[*Building][building]] to change those.

** how to use this document?
It's very straight forward, you edit the data, tangle the stuff and go for ~qmk compile~ or whatever you wanna do.
Be sure not to change anything in the [[*Building][building section]] unless you want to fork it since that might break stuff.
Currently the layout uses [[https://caniusevia.com/][via]] which enables us to set stuff the fast way without reflashing the firmware.
Not everything can be changed so if you need to set things like [[*encoders][encoders]], [[*combos][combos]], or oleds, you need to edit this file

* The keymap
** The layout
I primarily type in German, English and Swedish so the keyboard should be cabable or outputing the used characters like ~ü~ or ~å~.
For that I am using [[https://eurkey.steffen.bruentjen.eu/][EurKey]] - but US Intl should be fine too - on my system.  These are QWERTY layouts but they are able to output letters used in different languages using Alt Gr aka Right Alt.

*** handness
Since I use a split keyboard, handness is important, otherwise you end up with a mirrored/flipped layout.
If you want the right/left side to be master, throw ~MASTER_RIGHT~ or ~MASTER_LEFT~ in there.
If you - like me - use the eeprom to for determaning what side is master, leave it ~EE_HANDS~.
#+name: handness
#+begin_src C :main no :tangle no
EE_HANDS
#+end_src
** combos
Here, combos are a nice feature allowing to add keys at places where they don't impear your typing yet are comfortable to use

#+name: combo
#+begin_src C :main no :tangle no
// combo part here
#+end_src

** encoder
Rotary encoders add a lot of features and functionality, they are extremly useful.
For me, I like to have volume control on one side and window control on the other.

Simple structure is the function ~encoder_update_user(index, clockwise)~, this runs a simple /this encoder does this when turned clockwise, this then otherwise/.
#+name: encoder
#+begin_src C :main no :tangle no
bool is_alt_tab = false;
uint16_t alt_tab_timer = 0;

bool encoder_update_user(uint8_t index, bool clockwise) {
    if (index == 1) {
        if (clockwise) {
            tap_code(KC_VOLU);
        } else {
            tap_code(KC_VOLD);
        }
    } else if (index == 0) {
        if (clockwise) {
            if (!is_alt_tab) {
                is_alt_tab = true;
                register_code(KC_LALT);
            }
            alt_tab_timer = timer_read();
            tap_code16(KC_TAB);
        } else {
            if (!is_alt_tab) {
                is_alt_tab = true;
                register_code(KC_LALT);
            }
            alt_tab_timer = timer_read();
            tap_code16(S(KC_TAB));
        }
    }

    return false;
}

void matrix_scan_user(void) {
    if (is_alt_tab) {
        if (timer_elapsed(alt_tab_timer) > 1250) {
            unregister_code(KC_LALT);
            is_alt_tab = false;
        }
    }
}
#+end_src
* Building
** stuff
*** header
#+name: header
#+begin_src C :main no :tangle no
/* vim:ro
 * -*- buffer-read-only: t -*-
 *
 * This is autogenerated using doom/org-tangle DO NOT EDIT.
 * Please refer to main.org in [[https://git.sr.ht/~jat/keymaps]]
 */
#+end_src
*** license
#+name: license
#+begin_src C :main no :tangle no
/* Copyright 2021 Freja
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 #+end_src
*** matrix stuff
#+name: keymap
#+begin_src C :main no :tangle no
enum layers {
    _base = 0,
    _game,
    _lower,
    _raise,
    _adj,
    _misc,
};

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
         [_base] = LAYOUT(_______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______),
         [_game] = LAYOUT(_______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______),
         [_lower] = LAYOUT(_______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______),
         [_raise] = LAYOUT(_______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______),
         [_adj] = LAYOUT(_______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______),
         [_misc] = LAYOUT(_______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______),
};
#+end_src
** putting it all together
*** keymap.c
#+begin_src C :noweb yes :tangle keymap.c
<<license>>
<<header>>

#include QMK_KEYBOARD_H

<<keymap>>

#ifdef ENCODER_ENABLE
<<encoder>>
#endif

#ifdef COMBO_ENABLE
<<combo>>
#endif
#+end_src

*** config
#+begin_src C :noweb yes :tangle config.h
<<license>>
<<header>>

#pragma once

#define <<handness>>

#define LAYER_STATE_8BIT
#define DYNAMIC_KEYMAP_LAYER_COUNT 6

#define TAPPING_TERM 400
#define IGNORE_MOD_TAP_INTERRUPT

#ifdef OLED_DRIVER_ENABLE
#    define OLED_DISPLAY_128X64
#endif

#ifdef NKRO_ENABLE
#    define FORCE_NKRO
#endif

#ifdef RGBLIGHT_ENABLE
#    define RGBLIGHT_SLEEP
#    define RGBLIGHT_EFFECT_BREATHING
#    define RGBLIGHT_EFFECT_RAINBOW_MOOD
#    define RGBLIGHT_EFFECT_RAINBOW_SWIRL
#    define RGBLIGHT_EFFECT_SNAKE
#    define RGBLIGHT_EFFECT_KNIGHT
#    define RGBLIGHT_EFFECT_STATIC_GRADIENT

#    define RGBLIGHT_HUE_STEP 8
#    define RGBLIGHT_SAT_STEP 8
#    define RGBLIGHT_VAL_STEP 8
#    define RGBLIGHT_LIMIT_VAL 150
#endif

#ifdef ENCODER_ENABLE
#define ENCODER_RESOLUTION 2
#define ENCODER_DIRECTION_FLIP
#endif


// define USB_POLLING_INTERVAL_MS 5
#+end_src

*** rules
#+begin_src C :tangle rules.mk
OLED_DRIVER_ENABLE = no
RGBLIGHT_ENABLE = yes
WPM_ENABLE = no
MOUSEKEY_ENABLE = no
NKRO_ENABLE = yes
COMBO_ENABLE = yes
VIA_ENABLE = yes
ENCODER_ENABLE = yes

BOOTLOADER=qmk-hid
BOOTLOADER_SIZE=512
#+end_src

*** luna
Currently unused since I got no oleds on my kyria

#+begin_src C :tangle no
/*
 * this is the implementation of luna, the 4×3 keyboard pet.
 * see [[this][https://github.com/HellSingCoder/qmk_firmware/tree/master/keyboards/sofle/keymaps/HellSingCoder]] for more information
 *
 * this header uses a modified version to adapt to 128x64 screens
 * see [[here][https://gist.github.com/louckousse/74cd3f5cacf04fa585c127d89a149cfc]]
 * using this   header implies `OLED_ENABLE` and `WPM_ENABLE` are set to `yes` and thus defined
 */

<<license>>

#pragma once

// Animation frame defaults
#define MIN_WALK_SPEED 10
#define MIN_RUN_SPEED 40
#define LUNA_SIZE 96  // 96-byte arrays for the little dog
#define LUNA_FRAMES 2
#define LUNA_FRAME_DURATION 200  // Number of ms per frame

uint32_t        luna_anim_timer    = 0;
uint32_t        luna_anim_sleep    = 0;
uint8_t         luna_current_frame = 0;
static long int luna_oled_timeout  = 50000;

static void render_luna_sit(int luna_x, int luna_y) {
    static const char PROGMEM sit[LUNA_FRAMES][3][LUNA_SIZE / 3] = {
        // clang-format off
        {
            {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0x1c,
            0x02,0x05,0x02,0x24,0x04,0x04,0x02,0xa9,0x1e,0xe0,0x00,0x00,0x00,0x00,0x00,0x00},
            {0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0x10,0x08,0x68,0x10,0x08,0x04,0x03,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x02,0x06,0x82,0x7c,0x03,0x00,0x00,0x00,0x00,0x00,0x00},
            {0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x04,0x0c,0x10,0x10,0x20,0x20,0x20,0x28,
            0x3e,0x1c,0x20,0x20,0x3e,0x0f,0x11,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
        },
        {
            {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0x1c,
            0x02,0x05,0x02,0x24,0x04,0x04,0x02,0xa9,0x1e,0xe0,0x00,0x00,0x00,0x00,0x00,0x00},
            {0x00,0x00,0x00,0x00,0x00,0xe0,0x90,0x08,0x18,0x60,0x10,0x08,0x04,0x03,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x02,0x0e,0x82,0x7c,0x03,0x00,0x00,0x00,0x00,0x00,0x00},
            {0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x04,0x0c,0x10,0x10,0x20,0x20,0x20,0x28,
            0x3e,0x1c,0x20,0x20,0x3e,0x0f,0x11,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
        }
        // clang-format on
    };
    oled_set_cursor(luna_x, luna_y);
    luna_current_frame = (luna_current_frame + 1) % LUNA_FRAMES;
    oled_write_raw_P(sit[abs(1 - luna_current_frame)][0], LUNA_SIZE / 3);
    oled_set_cursor(luna_x, luna_y + 1);
    oled_write_raw_P(sit[abs(1 - luna_current_frame)][1], LUNA_SIZE / 3);
    oled_set_cursor(luna_x, luna_y + 2);
    oled_write_raw_P(sit[abs(1 - luna_current_frame)][2], LUNA_SIZE / 3);
}

static void render_luna_walk(int luna_x, int luna_y) {
    static const char PROGMEM walk[LUNA_FRAMES][3][LUNA_SIZE / 3] = {
        // clang-format off
        {
            {0x00,0x00,0x00,0x00,0x00,0x80,0x40,0x20,0x10,0x90,0x90,0x90,0xa0,0xc0,0x80,0x80,
            0x80,0x70,0x08,0x14,0x08,0x90,0x10,0x10,0x08,0xa4,0x78,0x80,0x00,0x00,0x00,0x00},
            {0x00,0x00,0x00,0x00,0x00,0x07,0x08,0xfc,0x01,0x00,0x00,0x00,0x00,0x80,0x00,0x00,
            0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x18,0xea,0x10,0x0f,0x00,0x00,0x00,0x00},
            {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x1c,0x20,0x20,0x3c,0x0f,0x11,0x1f,0x03,
            0x06,0x18,0x20,0x20,0x3c,0x0c,0x12,0x1e,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
        },
        {
            {0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x40,0x20,0x20,0x20,0x40,0x80,0x00,0x00,0x00,
            0x00,0xe0,0x10,0x28,0x10,0x20,0x20,0x20,0x10,0x48,0xf0,0x00,0x00,0x00,0x00,0x00},
            {0x00,0x00,0x00,0x00,0x00,0x1f,0x20,0xf8,0x02,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
            0x03,0x00,0x00,0x00,0x00,0x01,0x00,0x10,0x30,0xd5,0x20,0x1f,0x00,0x00,0x00,0x00},
            {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3f,0x20,0x30,0x0c,0x02,0x05,0x09,0x12,0x1e,
            0x02,0x1c,0x14,0x08,0x10,0x20,0x2c,0x32,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
        }
        // clang-format on
    };
    oled_set_cursor(luna_x, luna_y);
    luna_current_frame = (luna_current_frame + 1) % LUNA_FRAMES;
    oled_write_raw_P(walk[abs(1 - luna_current_frame)][0], LUNA_SIZE / 3);
    oled_set_cursor(luna_x, luna_y + 1);
    oled_write_raw_P(walk[abs(1 - luna_current_frame)][1], LUNA_SIZE / 3);
    oled_set_cursor(luna_x, luna_y + 2);
    oled_write_raw_P(walk[abs(1 - luna_current_frame)][2], LUNA_SIZE / 3);
}

static void render_luna_run(int luna_x, int luna_y) {
    static const char PROGMEM run[LUNA_FRAMES][3][LUNA_SIZE / 3] = {
        // clang-format off
        {
            {0x00,0x00,0x00,0x00,0xe0,0x10,0x08,0x08,0xc8,0xb0,0x80,0x80,0x80,0x80,0x80,0x80,
            0x80,0x40,0x40,0x3c,0x14,0x04,0x08,0x90,0x18,0x04,0x08,0xb0,0x40,0x80,0x00,0x00},
            {0x00,0x00,0x00,0x00,0x01,0x02,0xc4,0xa4,0xfc,0x00,0x00,0x00,0x00,0x80,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xc8,0x58,0x28,0x2a,0x10,0x0f,0x00,0x00},
            {0x00,0x00,0x00,0x00,0x00,0x0e,0x09,0x04,0x04,0x04,0x04,0x02,0x03,0x02,0x01,0x01,
            0x02,0x02,0x04,0x08,0x10,0x26,0x2b,0x32,0x04,0x05,0x06,0x00,0x00,0x00,0x00,0x00}
        },
        {
            {0x00,0x00,0x00,0xe0,0x10,0x10,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,
            0x80,0x80,0x78,0x28,0x08,0x10,0x20,0x30,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00},
            {0x00,0x00,0x00,0x03,0x04,0x08,0x10,0x11,0xf9,0x01,0x01,0x01,0x01,0x01,0x01,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x10,0xb0,0x50,0x55,0x20,0x1f,0x00,0x00},
            {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x0c,0x10,0x20,0x28,0x37,
            0x02,0x1e,0x20,0x20,0x18,0x0c,0x14,0x1e,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
        }
        // clang-format on
    };
    luna_current_frame = (luna_current_frame + 1) % LUNA_FRAMES;
    oled_set_cursor(luna_x, luna_y);
    oled_write_raw_P(run[abs(1 - luna_current_frame)][0], LUNA_SIZE / 3);
    oled_set_cursor(luna_x, luna_y + 1);
    oled_write_raw_P(run[abs(1 - luna_current_frame)][1], LUNA_SIZE / 3);
    oled_set_cursor(luna_x, luna_y + 2);
    oled_write_raw_P(run[abs(1 - luna_current_frame)][2], LUNA_SIZE / 3);
}

static void render_luna_bark(int luna_x, int luna_y) {
    static const char PROGMEM bark[LUNA_FRAMES][3][LUNA_SIZE / 3] = {
        // clang-format off
        {
            {0x00,0xc0,0x20,0x10,0xd0,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x40,
            0x3c,0x14,0x04,0x08,0x90,0x18,0x04,0x08,0xb0,0x40,0x80,0x00,0x00,0x00,0x00,0x00},
            {0x00,0x03,0x04,0x08,0x10,0x11,0xf9,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x80,0xc8,0x48,0x28,0x2a,0x10,0x0f,0x00,0x00,0x00,0x00,0x00},
            {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x0c,0x10,0x20,0x28,0x37,0x02,0x02,
            0x04,0x08,0x10,0x26,0x2b,0x32,0x04,0x05,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
        },
        {
            {0x00,0xe0,0x10,0x10,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x40,
            0x40,0x2c,0x14,0x04,0x08,0x90,0x18,0x04,0x08,0xb0,0x40,0x80,0x00,0x00,0x00,0x00},
            {0x00,0x03,0x04,0x08,0x10,0x11,0xf9,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x80,0xc0,0x48,0x28,0x2a,0x10,0x0f,0x20,0x4a,0x09,0x10},
            {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x0c,0x10,0x20,0x28,0x37,0x02,0x02,
            0x04,0x08,0x10,0x26,0x2b,0x32,0x04,0x05,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
        }
        // clang-format on
    };
    luna_current_frame = (luna_current_frame + 1) % LUNA_FRAMES;
    oled_set_cursor(luna_x, luna_y);
    oled_write_raw_P(bark[abs(1 - luna_current_frame)][0], LUNA_SIZE / 3);
    oled_set_cursor(luna_x, luna_y + 1);
    oled_write_raw_P(bark[abs(1 - luna_current_frame)][1], LUNA_SIZE / 3);
    oled_set_cursor(luna_x, luna_y + 2);
    oled_write_raw_P(bark[abs(1 - luna_current_frame)][2], LUNA_SIZE / 3);
}

static void render_luna_sneak(int luna_x, int luna_y) {
    static const char PROGMEM sneak[LUNA_FRAMES][3][LUNA_SIZE / 3] = {
        // clang-format off
        {
            {0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x40,0x40,0x40,0x40,0x80,0x00,0x00,0x00,0x00,
            0x00,0x00,0xc0,0x40,0x40,0x80,0x00,0x80,0x40,0x80,0x00,0x00,0x00,0x00,0x00,0x00},
            {0x00,0x00,0x00,0x00,0x1e,0x21,0xf0,0x04,0x02,0x02,0x02,0x02,0x03,0x02,0x02,0x04,
            0x04,0x04,0x03,0x01,0x00,0x00,0x09,0x01,0x80,0x80,0xab,0x04,0xf8,0x00,0x00,0x00},
            {0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x1c,0x20,0x20,0x3c,0x0f,0x11,0x1f,0x02,0x06,
            0x18,0x20,0x20,0x38,0x08,0x10,0x18,0x04,0x04,0x02,0x02,0x01,0x00,0x00,0x00,0x00}
        },
        {
            {0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x40,0x40,0x40,0x80,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0xe0,0xa0,0x20,0x40,0x80,0xc0,0x20,0x40,0x80,0x00,0x00,0x00,0x00,0x00},
            {0x00,0x00,0x00,0x00,0x3e,0x41,0xf0,0x04,0x02,0x02,0x02,0x03,0x02,0x02,0x02,0x04,
            0x04,0x02,0x01,0x00,0x00,0x00,0x04,0x00,0x40,0x40,0x55,0x82,0x7c,0x00,0x00,0x00},
            {0x00,0x00,0x00,0x00,0x00,0x00,0x3f,0x20,0x30,0x0c,0x02,0x05,0x09,0x12,0x1e,0x04,
            0x18,0x10,0x08,0x10,0x20,0x28,0x34,0x06,0x02,0x01,0x01,0x00,0x00,0x00,0x00,0x00}
        }
        // clang-format on
    };
    luna_current_frame = (luna_current_frame + 1) % LUNA_FRAMES;
    oled_set_cursor(luna_x, luna_y);
    oled_write_raw_P(sneak[abs(1 - luna_current_frame)][0], LUNA_SIZE / 3);
    oled_set_cursor(luna_x, luna_y + 1);
    oled_write_raw_P(sneak[abs(1 - luna_current_frame)][1], LUNA_SIZE / 3);
    oled_set_cursor(luna_x, luna_y + 2);
    oled_write_raw_P(sneak[abs(1 - luna_current_frame)][2], LUNA_SIZE / 3);
}

void animate_luna(int luna_x, int luna_y) {
    void animation_phase(void) {
        if (get_mods() & (MOD_MASK_SHIFT)) {
            render_luna_bark(luna_x, luna_y);
        } else if (get_mods() & (MOD_MASK_CAG)) {
            render_luna_sneak(luna_x, luna_y);
        } else if (get_current_wpm() <= MIN_WALK_SPEED) {
            render_luna_sit(luna_x, luna_y);
        } else if (get_current_wpm() <= MIN_RUN_SPEED) {
            render_luna_walk(luna_x, luna_y);
        } else {
            render_luna_run(luna_x, luna_y);
        }
    }

    // Animate on WPM, turn off OLED on idle
    if (get_current_wpm() != 000 || host_keyboard_led_state().caps_lock || get_mods() & (MOD_MASK_CSAG)) {
        oled_on();
        if (timer_elapsed32(luna_anim_timer) > LUNA_FRAME_DURATION) {
            luna_anim_timer = timer_read32();
            animation_phase();
        }
        luna_anim_sleep = timer_read32();
    } else {
        if (timer_elapsed32(luna_anim_sleep) > luna_oled_timeout) {
            oled_off();
        } else {
            if (timer_elapsed32(luna_anim_timer) > LUNA_FRAME_DURATION) {
                luna_anim_timer = timer_read32();
                animation_phase();
            }
        }
    }
}
#+end_src
